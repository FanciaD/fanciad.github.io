---
title: '[paper] "Should Tables Be Sorted?" and more'
date: '2025-04-09 12:03:45'
updated: '2025-04-09 12:03:45'
tags:
- Fancia
- Mildia
permalink: HopeInLight/
description: '"Should Tables Be Sorted?" and more'
mathjax: true
---

这是曾经某一篇文章的转生。

~~本来的url来着某个ea阶段的游戏，上次取了当时游戏已制作完成的最后一段剧情。那么很自然地这篇应该取自游戏的新更新，但url来源的游戏自那以后还没更新，这使得我取url的时候略显尴尬~~

#### Background: Ramsey Numbers

##### Basic Ramsey

一个众所周知的小学数学题：六个点的完全图做二染色（用小学数学的语境就是这些人两两之间是否认识），证明一定存在同色三元环。

解法很经典：考虑一个点的出边，必定有三条同色。如果这三个点之间有一条这样颜色的边那就搞定了，但否则的话这三个点之间又是一个同色三元环。

考虑一个自然的扩展：证明存在红色 $n$ 个点完全图或者蓝色 $m$ 个点完全图。最基础的 Ramsey 定理说，存在一个有限的 $R(n,m)$，使得只要有这么多点，那么一定满足上述条件。

这里的思想和上述解法很相似：考虑一个点的出边，假设有 $a$ 条红的和 $b$ 条蓝的。现在看那些红色出边连向的点。如果这些点之间有一个 $n-1$ 个点的完全图，那把第一个点加上就对了。所以红色部分如果达到了 $R(n-1,m)$ 个点，那这里面就能满足条件。类似的，蓝色部分不能达到 $R(n,m-1)$ 个点。那么两遍加起来就可以发现，只要有 $R(n-1,m)+R(n,m-1)$ 个点，则一定满足两边中的一个。所以：
$$
R(n,m)\leq R(n-1,m)+R(n,m-1)
$$

上述例子可以理解为 $R(2,3)=R(3,2)=3,R(3,3)\leq R(2,3)+R(3,2)=6$。

当然这个界显然不是紧的。事实上算 $R$ 是超级困难的。如果你感兴趣，可以尝试计算 $R(5,5)$。

##### Multi-Color Ramsey

如果有第三种颜色（比如白色）呢？此时也存在类似的 $R(a_1,a_2,a_3,\cdots)$。

证明可以重复上面的讨论，也可以直接每次把两种颜色捏起来，容易得到 $R(,\cdots,a_{n-1},a_n)\leq R(,\cdots,R(a_{n-1},a_n))$。

##### Hypergraph Ramsey

现在我们考虑 Hypergraph。此时一条“边”是一个大小为 $k$ 的集合。$n$ 个点的完全图是所有 $\binom nk$ 个集合对应的那些边。

从 $k=3$ 开始。我们考虑复用之前的分析：考虑判断一个 $R^3(n,m)$，此时从图里面随便拿一个点出来，我们需要红色部分有 $R^3(n-1,m)$ 个点，或者蓝色部分有 $R^3(n,m-1)$ 个点就行……但此时边不是不同的边，每条边还连了两个点，所以不能像之前那样直接分开。

仔细看一下这是在干啥——拿掉第一个点后，每条边还连向了两个点。我们需要要么找到 $R^3(n-1,m)$ 个点，使得它们中两个点和第一个点的边都是红色，或者类似地对于蓝色找到 $R^3(n,m-1)$ 个点……那么可以发现这就是上一层的 Ramsey $R^2$！也就是说，
$$
R^3(n,m)\leq R^2(R^3(n-1,m),R^3(n,m-1))+1
$$
那么显然把 $3,2$ 换成更大的一组数也对。事实上对于之前的情况也对：如果我们定义一个 $R^1$，那就是说每个点有颜色，然后问至少 $n$ 个红点或 $m$ 个蓝点，所以 $R^1(n,m)=n+m-1$。

因此不断归纳可知，任意 $R^k$ 都存在。

当然，这个上界的增长是非常恐怖的：每一步都是上一层的嵌套，熟悉的读者可以发现这和 Ackermann 比较有关（如果把 $k$ 看成输入）。或者也可以看简单情况：$k=2$ 是 pow，$k=3$ 是嵌套 pow 也就是指数塔，然后 $k=4$ 就难以描述了。

#### Should Table be Sorted?

我们回到正文。考虑 Dictionary/Hash table 问题：在 $m$ 个可能的 Key 中拿出 $n$ 个，每个询问是问一个 Key 是否存在。

考虑 Open Addressing Model：我们只能存 $n$ 个位置，每个位置正好存一个 Key。

有一些常见做法：

1. 直接排序做二分。那么平均最坏都是 $\log n$。
2. 做一些 Hashing。一波操作后可以做到平均 $O(1)$，但最坏非常差。

众所周知，如果你给序列排序存下来，那么最坏复杂度不能比 $\log n$ 好。我们想问，是否存在**最坏情况下**更好的做法？

但事实是，在某种情况下，任何的做法最后都包含了排序二分的做法。

考虑存 $n$ 个 Key 时，我们一定是按照某个顺序存了下来。给 Key 排序后，相当于每组 Key 我们选了一个顺序存下来。那么相当于每个 $n$ 元集合有一个 $[n!]$ 之间的记号表示顺序。

那么根据之前的 Hypergraph Ramsey，可以知道，当 $m$ 足够、足够、足够大时，我们一定可以找到 $2n$ 个 Key，使得它们中任意一个 $n$ 元子集都是按照某种大小顺序存下来的。因此，此时我们的算法不能优于二分查找。

#### A Closer Look to One Probe

考虑一个特殊情况：我们希望算法只问一次。请问此时给一个 $n$，我们能做多大的 $m$？

##### m>2n: Insufficient Probing

考虑我们的算法：每个询问会找一个位置，然后拿出来一个数回答这些询问。

假设有 $d$ 个询问找了这里，那么拿出的这个数就应该能回答 $2^d$ 种情况。也就是说，在这个位置上，我们把 $m$ 个元素分成了 $2^d$ 种，每种对应一个询问的回答。

那考虑安排掉这个做法：我们找到元素比较少的一种，然后选择这一种的情况，同时把这一种里面的元素全部扔掉。只要剩下还有 $n$ 个，我们就构造出了一种让算法寄掉的情况。

具体考虑一下。首先这 $d$ 个元素我们不能扔掉，因为它们表示了不同的情况。但即使每种元素代表一个情况，那还有 $2^d-d$ 个完全无关的情况。因此，总有一个情况里面没有这 $d$ 个元素，也只有 $m/(2^d-d)$ 个元素。只要 $d+m/(2^d-d)\leq m-n$，我们就能构造一个情况扔掉这所有东西，然后就寄了。

注意到 $d\geq m/n$，那么稍微解一下可以发现存在 $d\geq 3$ 的情况都是不可行的。因此我们接下来只需要考虑所有位置都 $d\leq 2$。

##### m=2n: A Close Look

现在考虑 $m=2n$ 的情况。根据上面的假设，每个位置必须被正好两个地方问。那么对于每个位置，我们记问这个位置的元素为 $a_i,b_i$。

考虑一个位置。此时有四种情况，而 $a_i,b_i$ 分别可以占据两种。我们仔细看一下：

1. 对于都不出现的情况（记作 O），这里不能用 $a_i,b_i$ 去占位。如果映射到这种情况的元素数量不超过 $n-2$，那我们就可以删掉 $a_i,b_i$ 和所有元素，然后就寄了。所以这里需要 $n-1$ 个。
2. 对于出现一个的情况（记作 A 和 B），我们可以用对应位置占位，然后随便放点。反之，如果元素数量不超过 $n-1$，我们就可以全删掉。因此此时需要 $n$ 个。
3. 对于都出现的情况（记作 AB），类似可以发现，我们要么拿一个位置占位，要么用 $n+1$ 个别的元素占位。

那么最好情况下，我们也需要 $(n-1)+n+1+1$ 个不同元素，这是不可能的。所以可以发现 $m<2n$……至少是在一般情况下。上述分析不生效的极端情况是 $n=1$，因此四种情况不一定出现。可以发现 $n=1$ 的时候正好能做 $m=2$。

~~事实上上面也漏了极端情况的讨论，但是我懒了~~

~~事实上下面也漏了极端情况的讨论，但是我懒了~~ 最极端的情况是 $n=3,m=5$，原论文写了一页。

##### m=2n-1: A/B Protocol Type 1

我们现在考虑上面的算法，首先我们一定希望拿 $a_i,b_i$ 去占两个位置。如果想做 $m=2n-1$，可以发现唯一能凑够数的方法是一个占位 AB，一个占位自己，这样 $m=2n-1$ 的时候，需要 $(n-2)+(n-1)+1+1=m$，正好。

根据对称性，不妨假设：如果只出现 $a_i$，那么把 $a_i$ 放这。如果两个都出现，那么把 $b_i$ 放这。还有一个位置只有一个人，这个位置记作特殊位置，那个元素可以记作 $x$。然后我们开始分析。首先单放一个 $a_i$ 相当于这个位置就没有出现，所以我们可以只看关键的位置。

1. 如果全都是 A，那么 $x$ 只能放到自己。从而特殊位置上 $x$ 表示出现。
2. 如果有一个 AB，那么 $a_i$ 会扔到特殊位置上，从而特殊位置上 $a_i$ 表示 $x$ 不出现。
3. 如果有一个 B，那么它不能扔到自己，因此只能和此时出现的 $x$ 互换。从而特殊位置上 $b_i$ 表示出现，别的位置上 $x$ 表示 type B。

接下来非常关键。

4. 如果有两个 AB，一个 O，$x$ 不出现。那么两个 $a_i$ 都要扔到空位上。那么可以发现，对于一个空位，几乎所有的 $a_i$ 都表示 type O：实际上最多有一个不满足这件事。
5. 如果有一个 AB，一个 B，$x$ 不出现。那么中间这个位置不能拿 $x$（表示 Type B），也不能拿自己的 $b_i$（表示 Type AB），也不能拿左边的 $a_1$（我们可以选一个，使其表示 Type B）。

可以发现这有一些本质的矛盾，即使换成 $m=2n-k$ 那上面差不多每个都换成“几乎所有都是”，就行了。因此我们只能去考虑另一类情况。

##### m=2n-2: A/B Protocol Type 2

换一种情况：如果只出现一个，那么放在这里。否则必须放在别的地方。

那很容易想到，一般情况下应该 AB 和 O 型配对。那就把所有 $a_i$ 表示 Type O，所有 $b_i$ 表示 Type AB，然后扔过去就行……但显然有极端情况需要考虑。

1. 如果有一对 AB 和 O 那就不行，因为 $b_i$ 也要换出去。所以 $m\leq 2n-1$。
2. 然后考虑有一个 $x$。那么上述情况下可以把 $b_i$ 和 $x$ 对换……但此时可以一个 AB，然后 $x$ 不出现。所以 $m\leq 2n-2$。
3. 注意到上面都是单个的问题，所以可以相信还能做。此时有两个 $x_1,x_2$。我们相信它们都表示 $b$。那么就这样：先把 $a_i$ 扔到没出现的位置里面去，然后所有 $b_i$ 和存在的 $x_i$ 一起换位。注意到本来就有两个 $x_1,x_2$，而如果删了一个就多出来一组 AB。所以至少有两个这样的东西，从而一定可以把 $b_i$ 换出去。

然后就结束了。注意到 $n$ 足够小的时候上述部分分析还是有细节问题。结论是 $n=1,m=2$，然后 $n=2,m=3$。更大一点的情况大力可知 $m=2n-2$。

值得注意的是 $n=2,m=3$ 的做法。此时二分不能做，解法是在第一个位置存没出现的元素的下一个数。或者叫做循环存。

##### Code

这甚至可以拿去出 OI 交互题。上次写这篇的时候想起了 OI 的传统。为了纪念，这里留下了一份 OI 风格的代码。

```cpp
#include "numbers.h"
int n;
void init(int _n)
{
    n=_n;
}
vector<int> arrange(vector<int> a)
{
    vector<int> occ(n*2-1),res(n);
    for(int i=0;i<a.size();i++) occ[a[i]]=1;
    vector<int> s1,s0;
    for(int i=1;i<=n-2;i++)
    {
        if(occ[i*2-1]!=occ[i*2])res[i-1]=i*2-1+occ[i*2];
        else if(occ[i*2])s1.push_back(i*2),s0.push_back(i*2-1);
    }
    int nw=1;
    for(int i=1;i<=n-2;i++)if(occ[i*2]&&occ[i*2-1])res[i-1]=s1[nw%s1.size()],nw++;
    for(int i=1;i<=n-2;i++)if(!occ[i*2]&&!occ[i*2-1])res[i-1]=s0[nw%s1.size()],nw++;
    for(int i=n-1;i<=n;i++)if(occ[n-2+i])res[i-1]=n-2+i;else res[i-1]=s0[nw%s1.size()],nw++;
    if(s1.size()==1)
    {
        int v1=s1[0],fr=v1/2-1;
        for(int i=n-1;i<=n;i++)if(res[i-1]==n-2+i)swap(res[i-1],res[fr]);
    }
    return res;
}

int getid(int x){return x>n*2-4?x-n+2:(x+1)/2;}
bool count(int x)
{
    int id=getid(x);
    int res=query(id);
    if(getid(res)==id)return res==x;
    else return res>n*2-4?1:res%2==0;
}
```

Paper Ref: Should tables be sorted?