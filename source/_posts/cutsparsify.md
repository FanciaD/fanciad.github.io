---
title: '[paper] Yet Another (Vertex) Cut Sparsifier'
date: '2025-05-17 19:41:06'
updated: '2025-05-17 19:41:06'
tags: Fancia
permalink: Hadopelagic/
description: Yet Another (Vertex) Cut Sparsifier
mathjax: true
---

无向图，无权图。

现在确实经常用的都是 Karger 那套了。但这东西比 Karger 那些早了8年，而且有趣得多。甚至对点双类东西也成立。

我们的问题是：给一个图，询问两点是否 $k$-连通。为此，我们希望找到一张图，使得如果 $s,t$ 两点的连通性 $\leq t$，那在新图上就是 $t$。然后如果更大，那现在至少是 $k$。

#### Edge Case

连通性有两种情况。最常见的是边连通性，相当于 $s$ 到 $t$ 最多能找到多少条边不交的路径。

根据最大流最小割，这等于我们能找到的最小 $s-t$ 割上边的数量。

首先，我们考虑这种 Exact Sparsifier 的下界是多少。那如果是个完全图，最后每个点往外的连通性都是 $k$。这样每个点度数就的是 $k$，从而至少需要 $O(nk)$ 条边。

这实际上没那么高效，这也是为什么之后大家开始做 $(1+\epsilon)$-approx 的版本，然后就有了 Karger 那套。

回到这里，那 $O(nk)$ 条边怎么做呢？一个惊人的观察是，我们有如下简单做法：

```cpp
for(int t=1;t<=k;t++)
{
    S=spanning_tree(E);
    G.add(S);
    E.delete(S);
}
```

说人话：每次在剩下的边里面找一个生成森林，然后加入 Sparsifier。

##### Analysis

这为什么是对的？

考虑使用最大流最小割定理。我们只需要证明，对于每个大小为 $c$ 的割，它现在的权值至少是 $\min(c,k)$。这样根据最大流最小割，我们考虑所有割，现在的连通性就至少是 $\min(t,k)$。（因为只删边，不可能增大 Cut 的值）

我们看看每一轮，一个割里面的边被选进来多少个。如果每轮拿进来一个，那就是最好的情况。

那显然，如果一个割还没有被拿完，则它们是唯一连接这两边的边，所有最大生成森林必须至少选一条。那么，在选完之前，每步至少选一个，这是好的。选完之后显然也是好的。证毕。

这自然对于每一轮都是对的。


##### Better Running Time

直接做复杂度是 $O(km)$ 的，这可比 $O(kn)$ 差多了。

当然熟练的 OI 选手应该会搞出一些 $\tilde O(m)$ 的做法。比如同时维护 $k$ 个并查集，然后二分到第一个不连通的生成树（并查集）加入。

但这篇文章还提供了一个非常有趣的做法。

```cpp
int h[N],used[N];
some_set S;
void solve()
{
    for(int i=1;i<=n;i++)s.insert(i);
    for(int t=1;t<=n;t++)
    {
        int u=s.get_highest_vertex();
        s.delete(u);used[u]=1;
        for(auto v: ed[u])
        if(!used[v]&&h[v]<k)
        {
            h[v]++;h[u]=max(h[u],h[v]);
            s.update_height(v);
            add_edge(u,v); // add to tree h[v]
        }
    }
}
```

请自行参考代码。因为每次 $h$ 只有 $+1$，这东西甚至可以线性维护，然后得到真的不带 $\log$ 的线性算法。

这又为什么是对的？我们希望证明，上面我们把边分到了 $k$ 棵树，然后按照之前做法，每棵树都是当前的最大生成森林。

因此我们希望证明，如果有一条边被加到了某棵树里面，那前面的树都不需要它了：前面的树上，这条边两个端点已经连通。那可以发现坏的情况就是某个 $h$ 上，两边连通块分别抬到过了 $h$ 而没有管中间，此时中间这条边就跑到了后面的树上去。

但上面取最大 $h$ 的一步保证了这是不可能的：如果一边先出现了一个 $h$ 很大的连通块，那接下来我们不会去新开一个连通块，而是先在这里面搜，这样就会沿着中间的边走过去，而不是先把右边做了然后发现中间这条边悬空了。

那么就证完了。

#### Vertex Case

还有一种情况是点双类型，也就是找到很多除去 $s,t$ 外点不相交的路径。我们可以把这东西看成网络流：拆点 in/out，那样连边 $1$，原来的路径边连 $+\infty$。然后再搞最小割，可以得到如下定义的 Vertex Cut：

我们选一个点集 $S$，将点集分成 $L,S,R$，使得 $L/R$ 不连通且 $S$ 尽量小。

然后有非常非常非常有趣的一点：上述最后一个算法经过eps点修改，直接拿来跑这个就是对的。

考虑这次我们要证明什么。相当于，任意考虑一个 $L,S,R$ 的 Vertex Cut，我们要说 $S$ 里面都选了至少 $\min(|S|,k)$ 个点，每个点有一条从 $L$ 到 $R$ 的连接。那直观上看，我们的目的和之前一样：我们希望，每一棵树选了其中的一个点，使得这个点在这一棵树上有一条从 $L$ 到 $R$ 的路径。

好消息是，每棵树需要一个点连接，所以我们确实会选这么多个。

但坏消息是，你可能两轮选了同一个点的不同路径，这在点双上就炸了。

这时我们就需要上面的算法发力了。

##### Analysis

考虑一个割 $L,S,R$ 中的 $S$。假设我们从左边开始。在第一次选 $S$ 的点之前，我们不会加右边的边，所以右边高度都是 $0$。

那么我们第一次选中间某个点的时候，它往右的边都加到 $h=1$ 这一层上，那么可以发现：

> 对于第一个访问到的点，它只在 $h=1$ 的树上有用，有用的意思是提供 $L-R$ 的路径。

有没有一般情况的结论呢？可以类似地尝试证明：

> 对于第 $i$ 个访问到的点，它只在 $h\leq i$ 的树上有用

$\leq$ 是必要的，因为可能全部在第一层搞完了。

考虑归纳证明。$i=1$ 就是上面的情况，考虑某一个 $i\to i+1$ 怎么做。

那根据之前的结论，前 $i$ 个点只在前 $i$ 棵树上有用。因此在访问下一个 $S$ 中的点之前，两侧与 $S$ 直接相连的部分不会同时出现 $h>i$ 的东西：如果一边出现了，那必然沿着 $S$ dfs 过去。（有可能两边分别出了一些孤立连通块，但这不影响）因此无论如何，当从一侧访问到 $S$ 中下一个点时，另一侧都是 $h\leq i$，从而这个点向这一侧的路径只会加到前 $i+1$ 棵树上。

那么它就对了：每加入一棵新的树时，前 $i$ 个访问到的点都不会有用，所以如果前面只放进来了 $i$ 个点，那我们必须拿出一个新的点来让现在连通。