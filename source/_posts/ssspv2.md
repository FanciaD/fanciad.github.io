---
title: '[paper] Negative Weight SSSP [Second Edition]'
date: '2025-12-06 22:22:22'
updated: '2025-12-06 22:22:22'
tags: Fancia
permalink: OmBlaSras/
description: Negative Weight SSSP
mathjax: true
---

有人读了我的 {% post_link sssp '上一篇' %} ，觉得写得太过抽象，所以重写一遍。

### Real Weight SSSP V4

#### Prelim

我们定义一些常见的，以及不常见的记号。有一些记号来自于新的论文，所以现在不知道是正常的，但这里也列出来作为参照。

##### Complexities

为了展现主要矛盾，此处所有时间复杂度都忽略 $\log$，也就是默认 $\tilde O$。有时，我们还会忽略一些更大的东西，比如 $\exp(\log\log^2 n)$。

然后我还懒得写 $\tilde O$，所以会出现如下类型的记号：Dijkstra 的复杂度是 $m$ 的。

##### Basic Graph notations

我们用 $G=(V,E)$ 表示图，$V$ 表示点集，$E$ 表示边集。我们令 $n=|V|,m=|E|$。在这里，我们都考虑有向图。

这里图会有负权边。众所周知，没有负权的情况是简单的，所以我们通常会分开考虑两种边。定义 $E^+$ 表示非负边的集合，$G^+$ 表示只保留非负边得到的图。

负权边是关键的，所以我们用 $k$ 表示它的数量。后面我们可以看到，我们可以让 $k=O(n)$。另一方面，很多复杂度实际上可以写成 $k$ 相关的函数，它们实际上都是 $mk^c$ 的复杂度。这在某个时候会有用。

##### Distances and Hops

令 $d(u,v)$ 表示 $u$ 到 $v$ 的距离。有时我们会写单源最短路，对于一个 $u$ 求出所有 $d(u,v)$，此时记作求出 $d(u,\cdot)$。

我们想用 $d$ 做一些事情，但求一个 $d(u,v)$ 已经是 SSSP 的难度了，所以我们会用一些简单的版本：
称一条路径的 Hop 数是它经过的负权边数量。我们用 $d^h(u,v)$ 表示只考虑 h-hop 内的路径的最短路。有时，我也会用 hop 表示经过的一条负权边。

那么 $d^h(u,\cdot)$ 可以 $mh$ 求：考虑求出 $d^0$ 直到 $d^h$，那么 $d^i$ 到 $d^{i+1}$ 只需要先转移一轮负权边，然后再在 $G^+$ 上做一次 Dijkstra。

##### Johnson Reweighting

对于一个图 $G$，我们可以拿出一个 $\phi$，然后修改边权：$w(u,v)\to w(u,v)+\phi(u)-\phi(v)$。

这样的好处是，如果我们考虑一条 $s$ 到 $t$ 的路径的权值和，那么中间的项都会消掉，从而只剩下 $\phi(s)-\phi(t)$。因此新的图上的最短路可以求出原图的最短路。

更好的是，如果我们选一些边，求最短路来做 $\phi$，即 $\phi(u)=d(\cdot,u)$，那么根据三角形不等式，我们有 $d(\cdot,u)+w(u,v)\geq d(\cdot,v)$，因此 $w(u,v)+\phi(u)-\phi(v)\geq 0$。也就是说，这些边现在就变成了正权边。

后面我们会很经常地使用这样的技巧：保留一些边求最短路，然后用这个 $\phi$ 去处理原图。同时，最常用的最短路是从所有点开始跑，即 $d(V,u)$；这也可以看成，一开始所有点都是 $dis=0$，然后去更新。这也有一些很好的性质。

在后面，我们会经常使用 $d_\phi$ 表示在 $\phi$ 的 Reweighting 下的距离，也就是 $+\phi(u)-\phi(v)$ 的结果。



接下来我们讲一些论文中的定义。

##### Hop reducers

我们称 $H$ 是 $G$ 的一个 h-hop reducer，如果 $H$ 里面有 $G$ 的点，然后 $d_G(u,v)\leq d^1_H(u,v)\leq d^h_G(u,v)$。（此处下标表示在哪个图里面，这样的用法只在这里有一次。）意思是说，$G$ 里面的 $h$-hop 路径都可以在 $H$ 上一步解决，同时 $H$ 里面的路径在 $G$ 里面都是合理的，不会超过 $G$ 里面的最短路。

那么直接有如下结论：$H$ 上求 $n/h$-hop 的最短路即可求出 $G$ 的最短路。

这里有一个显然的 hop reducer 构造：考虑造一个 $h$ 层的分层图：我们把 $G^+$ 复制 $h$ 次，然后在相邻两层之间连上负权边，就像做 $h$-hop 最短路那样。然后，我们在最后一层到第一层之间也连上负权边。这样，从第一层回到第一层的路径就经过了 $h$ 个负权边。不过我们不一定要用完这些负权边，所以我们再在相邻两层之间连从自己到自己的边。

然后考虑把最后一层到第一层的边删掉，对图跑最短路，得到 $\phi$ 后把这些边加回来，用 $\phi$ 做 reweight。此时，图里面只有这最后一层的边可能是负的，从而我们可以用 1-hop 模拟 $h$-hop（注意到如果 all-source 的话，第一层一定 $\phi=0$）。

但这样图的大小是 $mh$ 的，所以直接搞是 $mh\cdot n/h$，这样没什么用。

##### Negative Reaches

定义一个点的 Negative Reach 为 $R(u):=\{x|d(u,x)<0\}$。顾名思义，这就是它能够在负数距离内到达的点。

和之前一样，我们也可以限制 $h$-hop，然后说 $R^h$。

我们也可以对一个集合的点说 Negative Reach，就是把它们分别的并起来。你也可以想象成多源最短路。

我们还可以对一条边说 Negative Reach，表示从这条边出发，后面一样。

那这东西有什么用呢？如果一条负权边的 $R$ 很小，那我们可以 $|R|$ 地处理加入它之后最短路（或者说 $\phi$）的变化。对一个集合也一样。

那怎么说明一个集合的 $R$ 很小呢？有一个想法：如果我们知道一个点 $u$ 的 $R$ 很小，但 $u$ 同时又能 Negative Reach 很多负权边，那这些负权边的 $R$ 都被 $R(u)$ 包含，这就说明了一个集合的 $R$ 很小。

因此我们希望一个点的 $R$ 不大，但里面有很多负权边。对于后者，我们可以贪心解决（见后面）。但前者看起来很难，直到有人发现，把 $R$ 两边拼起来，好像就能做了，这样就有了如下两个概念：

##### Betweenness

我们定义 $BW(s,t)=\{x|d(s,x)+d(x,t)<0\}$，这就是把两边拼起来。类似的，可以加 $h$-hop 的限制。然后还有

##### Negative Sandwiches

我们称 $(s,U,t)$ 是一个 $h$-hop negative sandwich，如果 $U$ 是一个负权边集合，然后我们考虑每一个负权边的起点。

（实际上有一堆相近的定义，比如两边分别不超过 $h$-hop 啥的，但是这些之间差距不大，影响不大）

#### Common Assumptions

如果一个点连出去很多条负权边，那我们拆一个点，拉一条非常大的负权边，把连出去的那些边都变成正的（例如，本来权值是 $-9,-8,-7$，现在先拉一条 $-10$，然后从那边拉出去 $1,2,3$ 的边）。这样，我们可以假设只有 $n$ 条负权边。

然后我们可以通过拆点来保证度数均匀，即所有点都是 $O(m/n)$ 的度数。这样的好处是，我们很多时候拿到一个 $n/t$ 级别的 $R$ 或者 $BW$，然后我们就可以直接翻译成这个子图只有 $m/t$ 条边。~~当然实际上不需要这样做，因为可以把 BW 定义成边数相关，或者说度数，然后就直接行了~~

#### Neutralization Framework

话接 Johnson Reweighting，如果我们选了一些负权边 $U$，对 $U\cup E^+$ 的部分求了一个 $\phi$。那么作用这个 $\phi$ 后，这些边的权值都是非负的了。此时，我们可以保留这个 $\phi$，然后在之后的过程里面把 $U$ 里面的边都看成正权边。这被称作 Neutralize 了 $U$ 里面的负权边。

那么复杂度取决于我们 Neutralize 的效率：考虑 Naive 想法，我们可以 $mk$ 的时间求出 $k$ 条负权边的图的最短路，这样就是 $mk$ 时间解决了 $k$ 条边，但这样复杂度自然是 $mn$。

不过在后面我们将会看到，我们可以任意选择 $U$，然后我们可以做到更好的效率，从而击败 $mn$ 的界。

接下来我们依次介绍这一系列的算法，所有的标题都是 arxiv id。

#### 2311.02520

怎么做到更好呢？我们需要一系列的结果：

##### Negative Reach -> Better Hop Reducer

我们考虑之前的 Hop Reducer，但我们还保证对于选的负权边 $U$，$R^h(U)$ 是一个不大的值。这里 $h$ 是多少、$R^h$ 有多大都是待定。

那么考虑之前做 Hop Reducer 的方式，我们在 $h$ 层分层图上跑最短路。那么 $R^h$ 保证，对于 $R^h(U)$ 外面的点，它们每一层的 $\phi$ 都是 $0$——但这怎么用呢？

注意到，在之前的分层建图里面，我们可以随意加一些边权为 $0$ 的，从下一层跳回上一层的边——这样不会让 Hop Reducer 变得不合法，因为只是加入了一些 Hop 更多的路径。

但如果我们给 $R^h$ 之外的点都加上了这些边，那它们每一层的点之间就有双向 $0$ 权边——所以我们可以缩点！最后就只需要对 $R^h$ 里面的部分复制 $k$ 次。

那么此时的图大小为 $m\cdot(R^h(U)/n)\cdot h+m$，此时求出 $|U|/h$-hop 的最短路即可在原图求出 $|U|$-hop 最短路。那么最常用的情况是，如果 $R^h(U)\leq n/h$，Hop Reducer 的大小就是 $m$ 的，然后后面是 $m|U|/h$ 的，另外，求 Hop Reducer 是 $mh$ 的。

##### Negative Sandwich + Betweenness Reduction -> Negative Reach

上一步说明，如果我们能找一个集合 $U$，使得 $R^h(U)\leq n/h$，那我们就赢了。

但直接做很难，我们也没有一个东西叫做 Negative Reach Reduction——请自行思考为什么后面那个想法对 $R^h$ 没有用。

考虑一个直接的想法：如果我们希望对于别的点 $x$，我们都有 $d^h(U,x)\geq 0$，那自然考虑 Reweighting，让 $\phi(x)=d^h(U,x)$，这样对于 $u\in U$，我们有 $d^h_\phi(u,x)=d^h(u,x)-d^h(U,x)+d^h(U,u)$……但你就会发现，如果 $\phi(u)<0$，这就寄了。

那么我们希望 $\phi(u)\geq 0$，所以需要对它做一些操作，好消息是，我们可以这样：

> 称一个 $\phi$ 是 valid reweighting，如果它使得所有非负边现在还是非负的。两个 valid reweightings 的 $\max,\min$ 都仍然是 valid reweighting。

证明就考虑一条边然后分析一下情况。

那么，naive 的想法是直接 $\max(d^h(U,x),0)$。但仔细想想，这样就直接让所有本来在 $R^h$ 里面的点都爆掉了。那有没有更好的让 $\phi(U)\geq 0$ 的方法？

注意到可以用 $\max(d^h(U,x),-d^h(x,U))$。后者是反向最短路，所以还是对的。这样的话，$u$ 里面的点 $\phi$ 自然是非负的，因为 $d^h(u,U)$ 实在不行可以取 $0$。然后对于外面的点，如果它们 $\max$ 取第一项，这就是好的。因此现在还在 $R^h$ 里面的点一定先前 $d^h(U,x)+d^h(x,U)<0$。

（这个时候再写成边就有点抽象了，因为有两个方向。这里做一个规范：我们在 $d$ 里面写一条边的时候，都是表示它的起点。这样 $d^h(U,\cdot)$ 是经过了第一条边，但 $d^h(\cdot,U)$ 没有。不过后者不是问题，因为我们只需要 $\leq 0$。）

现在我们得到了一个集合的 Betweenness。但这很难处理。因此类似之前提过的一个想法，我们用一个点把它们包起来，然后就变成了单点 Betweenness。

注意到如果你的 Negative Sandwich 的定义是 $d^h(s,u)<0,d^h(u,t)<0$，那么我们直接有 $d^h(U,x)+d^h(x,U)<0$ 推出 $d^{2h}(s,x)+d^{2h}(x,t)<0$，从而 Betweenness 加上 Negative Sandwich 可以推出 Negative Reach。事实上这就是这里的做法。

不过后面把 Sandwich 定义换成 $d^h(s,u)+d^h(u,t)<0$ 了，然后就不能这么简单地推了。但是还是可以证明：

> 如果我们有 $h+r$-hop Betweenness $(s,t)$ 和 $h$-hop Sandwich $(s,U,t)$，我们就能有 $r$-hop Negative Reach $R^r(U)$，满足 $R^r$ 一定在最初的 $BW^{h+r}(s,t)$ 里面。
>
> 做到这件事只需要 $\phi(u)=\max (d^{r+h}(s,u),-d^{r+h}(u,t))$（注意这和上一版的区别。）

> 证明：取 $x\not\in BW^{h+r}(s,t),u\in U$，我们希望证明 $d^r(u,x)+\phi(u)-\phi(x)\geq 0$。
>
> $x$ 在 BW 外面，所以它的 $\max$ 取第一项 $d^{r+h}(s,x)$。而 $u$ 在 negative sandwich 里面，所以 $d^h(s,u)+d^h(u,t)<0$。那自然换成 $r+h$-hop 也一样，所以它取第二项。此时变成 $d^r(u,x)-d^{h+r}(u,t)-d^{h+r}(s,x)$。
>
> 注意到 $d^{h+r}(s,x)\leq d^h(s,u)+d^r(u,x)$。换一下（多减一点只会变小）得到 $-d^h(s,u)-d^{h+r}(u,t)$，这大于 $-d^h(s,u)-d^h(u,t)$，所以这是正的。

此时我们就只需要两个东西：一个很大的 $h$-hop Sandwich $(s,U,t)$，配上一个 $BW^{r+h}(s,t)\leq n/r$。（有一些记号问题，这里 $R$ 用的 r-hop，所以上面 hop reducer 也是 $r$-hop。但很快我们直接让 $r=h$，所以不管了）

要同时达到两个东西，会有一些奇异的限制：两边可能都想确定一个 $s,t$，但最后必须收敛到同一对。同时，我们看到上面的构造用了 Reweighting。但这里显然不能造两个的时候都 Reweight，因为搞一个会让另外一个被破坏掉。

这里找到了一种解决方式——一边可以 Reweight，但是要对每一对 $s,t$ 都成立；另一边不能 Reweight，但只需要找一对 $s,t$。

##### Betweenness Reduction

考虑让每一对 $BW^h(s,t)$ 都很小。那为了这件事，我们显然需要加一个 $\phi$ 上去。这件事显然是可能的：如果取真正的最短路作为 $\phi$，那所有 BW 都是 $0$。

现在考虑一对 $(s,t)$ 的 $BW^h$，对于一个中间点 $x$，它在加了一个 $\phi$ 后的距离是 $d_\phi^h(s,x)+d_\phi^h(x,t)=d^h(s,x)+d^h(x,t)+\phi(s)-\phi(t)$。
可以发现这就是在原来的值上面加了一个与 $x$ 无关的值 $\phi(s)-\phi(t)$。每个 $x$ 对应的量都加了这个值，所以它们之间的大小关系不变。我们把 $d^h(s,x)+d^h(x,t)$ 称作 $x$ 在这里的 thrust，那希望 BW 很小就相当于，我们希望 $\phi(t)-\phi(s)$ 最多比 $n/b$ 个 thrust 大。

怎么做到让 $\phi(t)-\phi(s)$ 不大于某个值呢？因为 $\phi$ 是个最短路，我们可以在那个图里面加一条 $s$ 到 $t$，边权为某个 $x$ 的 thrust 的边，这样就可以保证。

选哪个 $x$ 呢？我们并不知道这些相对关系，还有很多对 $(s,t)$。但我们知道，在 $n$ 个数里面随机 $b\log n$ 个，我们就能 whp 找到一个前 $n/b$ 小的。因此我们随机 $b\log n$ 个点作为 $x$，就可以保证 whp 所有的 BW 不超过 $n/b$。

然后注意到对于每个 $x$，我们暴力的话是对每一对 $s,t$，加 $d^h(s,x)+d^h(x,t)$ 的边，那显然可以拆一下：对于每个 $x$，我们加一个新点 $x'$，然后从每个 $s$ 向它连边权为 $d^h(s,x)$ 的边，再从它向每个 $t$ 连 $d^h(x,t)$ 的边。这样就只需要连 $nh$ 条边。

那么就可以得到一个做法：连上面这些边，然后在这个图上跑最短路，用得到的 $\phi$ 作用原图（用对应点的点权）。

（一个事情是，为了保证 $\phi$ 对正权边合法，我们看起来需要直接在原图加一个 $G^+$ 的边。这不影响下面的复杂度分析。但你也可以不加，可以证明这样是对的，原因是 $d^h(x,t)$ 可以保证考虑了正权边，因为正权边不算 hop。更具体的说，假设不加边，某个点 $u$ 的最短路最后从 $x$ 过来。那么 $d(u)=d(x)+d^h(x,u)$，这里第一个 $d$ 表示新的图上的距离。然后对于一条非负边 $u\to v$，我们有 $d^h(x,v)\leq d^h(x,u)+w(u,v)$，所以 $d(v)\leq d(x)+d^h(x,u)+w(u,v)$（你可以从 $x$ 过来，也可以选这种转移，但都有可能更优）。这就说明 $w(u,v)$ 在新的 $\phi$ 下仍然非负。）

然后考虑复杂度。在希望 $BW^h\leq n/b$ 的时候，我们需要 $b$ 个点（我知道应该有 $\log$，但我懒），然后边权是 $h$-hop 的最短路，所以这部分复杂度是 $mhb$。然后需要在那个图上跑最短路。这里图的一侧是 $b$ 个点，另一侧是 $n$ 个点，不过另一侧可能还有个 $G^+$。但有不有不影响我们这样做：每次从右边更新左边，再左边更新右边，再在右边的非负边权里面跑一轮最短路，这样做 $b$ 轮就可以处理经过左边任意次的路径。复杂度是 $nb^2$。

因此，我们得到了第一部分：我们可以在 $mhb+nb^2$ 的时间内找到一个 $\phi$，作用后保证 $\forall s,t, BW^h(s,t)\leq n/b$。（这是 whp 的，但我懒得写了）

实际上你也可以把 $nb^2$ 给扬了：考虑求出左边 $b$ 个点的 APSP，然后只需要右边更新一次左边，然后左边内部 APSP，然后左边更新右边。这样需要左边两两从右边绕一圈的距离，显然没法算。但注意到往右边绕一圈是两个 $h$-hop 路径拼起来，所以算左边的两两 $2h$-hop distance 就可以了。这样就变成 $mhb+b^3$ 了。

##### Sandwich Construction

然后是另外一边，我们需要找到一个 Sandwich $(s,U,t)$。

这里不能再 Reweight 了，所以我们还是会面临一些图根本没有 Sandwich 的情况。但好消息是——如果一个图是这样，我们有一些别的方法来解决它。这就像一种 win-win。

我们先考虑最简单的情况：假设我们想要的不是 Sandwich，而是之前说的半个 Sandwich：$(s,U)$ 满足 $\forall u\in U,d^h(s,u)\leq 0$。这个情况非常简单。如果对于每个 $s$，合法的 $U$ 都很少，那怎么办？

考虑另外一种求最短路的过程：我们把一条负权边放进去，然后希望找到一个 $\phi$ 使得它变成正权边。那么，我们令 $\phi(u)=0,\phi(v)=w$，然后向后搜，更新后面的 $\phi$（如果当前点还是 $-c$，后面有一个边权是 $l$ 的边，那么下一个点可以 $\phi=-c+l$。）这样更新到的点就是它的 Negative Reach $R$（如果只有这条负权边，那就是 $R^1$），这也是之前说的那个 $R$ 很小时候的做法。（不过你直接这样做会有一些问题，因为下一条边进来的时候，这条边就得当作正权边了。因此下一次做的时候，$R^1$ 就变成不考虑之前解决的边。或者你也可以直接写 $R$。）

但我们可以有比单个点 $|R|$ 更好的做法：考虑很多负权边一起开始搜，只在 $G^+$ 上搜。如果两个点搜到一起了，那我们只用保留更小的 $\phi$ 继续。这样唯一的问题是，如果我们搜到了某个负权边的起点，当前 $\phi$ 还是负的，那就爆了，得重新更新。

但上面的过程就说明，如果我们能找到一些负权边，它们的 $R^1$ 不包含其他的起点，那么我们就可以 $O(m)$ 找到一个 $\phi$，解决这些负权边。

回到之前的问题，如果每个 $s$ 的 $R^1$ 都只包含很少的 $u$，那我们就可以选出很多的点，满足上面那个条件。更具体地，如果每个 $s$ 都只影响 $b$ 个位置，那我们可以选出一个 $n/b$ 大小级别的集合。（证明：现在这里是出度 $b$，可以转换为一半的点度数不超过 $4b$，然后就可以直接贪心了。）

那么我们可以要么解决 $k^{1/2}$（这里 $k$ 表示负权边数量）条边，或者我们就找到了 $k^{1/2}$ 大小的 $(s,U)$。不过算法怎么写呢？我们没办法快速求出每个 $s$ 对应了多大的 $U$。但这里可以采样：随机一些点作为 $u$，跑一个反向最短路，就可以判定一个 $s$ 对应的 $U$ 是否和随机的集合有交。然后就可以估计大小了。

那 $(s,U,t)$ 怎么办？我们先找到一个很大的 $(s,U)$，然后对 $U$ 里面的部分再反过来做类似的东西，去找到 $t$。这样的话，正确的参数应该是：第一轮，要么解决 $k^{1/3}$，要么找到 $k^{2/3}$ 大小的 $(s,U)$；第二轮，要么解决 $k^{1/3}$，要么在里面找到 $k^{1/3}$ 的 $(U',t)$，然后就搞定了：我们可以在 $m$ 的时间内，要么解决 $k^{1/3}$ 条边，要么找到 $k^{1/3}$ 大小的 1-hop sandwich。

不过，为什么两边要相等呢？直接看过去，好像第一种情况就不需要后面的步骤了，但第二种情况后面还要搞一大堆东西，所以这不大平衡。问题是，按照这个分配，我们必须先跑上一步的 BW Reduction，再来找 Sandwich。而 BW Reduction 的复杂度特别大，结果平衡下来这样就是最好的了。马上我们来算一遍。

##### All Together

现在我们把之前的东西全部拼起来。记 $h$ 表示我们想要的 hop 数。因为这里 sandwich 固定是 $1$-hop，所以应该 BW 是 $h+1$-hop，然后 Negative Reach 是 $h$-hop。我们再假设 BW 给的值是 $n/b$。记 $q$ 表示我们想要的 $|U|$，然后算一遍：

1. Betweenness Reduction 复杂度为 $mhb+nb^2$。
2. 在 Sandwich 步骤，我们要么找到 $q$ 的 Sandwich，要么解决 $\sqrt{k/q}$ 的边数。
3. Sandwich 构造是 $m$，Hop Reducer 构造是 $mh$，可以忽略。
4. 使用 Hop Reducer 是 $mq/h(1+h/b)$。

怎么分析这堆复杂度呢？（喜报：我上个月（25/11）才会这种分析）

1. 看一下 sandwich 的情况，此时 Hop Reducer 处一条边的用时是 $m(1/h+1/b)$。
2. 看一下 sandwich 的情况，此时 BW 处一条边的用时是 $m(hb/q)$。
3. 看一下直接解决的情况，此时一条边的用时是 $m(hb/\sqrt{k/q})$。

我们希望这三个系数的最大值最小。那固定 $hb$，看第一项容易发现 $h=b$ 最优（喜报：这样可以顺便不管 $nb^2$）。然后看后两项容易发现 $q=\sqrt{k/q}$ 更优，就是 $q=k^{1/3}$。

此时用时是 $m(1/h+h^2/k^{1/3})$。平衡这两项可知 $h=b=k^{1/9}$，最后一条边用时 $m/k^{1/9}$，或者说我们用 $mk^{2/9}$ 的时间解决了 $k^{1/3}$ 的边。

因此复杂度 $mk^{8/9}$。（实际上 $k$ 变小的时候每条边的用时在变大，但这种情况的边数量很少，算一下调和级数最多多一个 $\log$。）

#### 2407.04872

如果你完全地理解了上面的工作，那理解接下来的部分是比较容易的。

上面有很多个步骤。如果我们能优化其中一个，我们就有希望优化整体的复杂度。这确实也是接下来发生的一系列事情。

##### New Sandwich Construction

首先这里把 Sandwich 的定义从 $d^h(s,u)<0,d^h(u,t)<0$ 变成了 $d^h(s,u)+d^h(u,t)<0$，但我在上面已经偷懒写过了，所以就不重新分析了。

新的定义有一个好处：如果我们有一条长度为 $h$ 的负权值路径，那么路径上每个点都在 Sandwich 里面，这样就有了一个 $h$ 大小的 Sandwich。

那怎么判定有没有这样的路径呢？考虑做 $h$-hop 最短路，初始时所有点 $d=0$。然后如果最后一轮更新了，那就一定有这样的路径。（其实没更新不一定没有，但不知道怎么推到更好）。如果没有更新会发生啥？那后面就不会更新了，所以现在就 $d^h=d$ 了。因此这种情况下我们直接赢了，即我们可以把所有边都解决掉，而用时只有 $mh$。

但 Sandwich 的情况又太差了。这能不能平衡？做法是使用 Sampling：考虑随机 $k/c$ 条边，此时如果有一个 $h$ 大小的 Sandwich，那大概说明原来应该有 $ch$ 大小的 Sandwich。类似地，我们可以任意平衡解决的边数和 Sandwich 的大小，只要它们乘起来是 $kh$。

严谨的证明：我们可以证明，任意固定 $n^2$ 个集合，whp 它们满足，如果一个集合原来大小 $\leq ch$，那么它和 $k/c$ 采样的交不超过 $h$ 级别（这次是 Chernoff，所以常数倍差距已经可以 whp 了，感恩）。

现在复制一遍之前的分析：

1. Betweenness Reduction 复杂度为 $mhb+nb^2$。
2. 在 Sandwich 步骤，我们要么找到 $q$ 的 Sandwich，要么解决 $kh/q$ 的边数。
3. Sandwich 构造是 $mh$，Hop Reducer 构造是 $mh$，可以忽略。
4. 使用 Hop Reducer 是 $mq/h(1+h/b)$。

所以，

1. 看一下 sandwich 的情况，此时 Hop Reducer 处一条边的用时是 $m(1/h+1/b)$。
2. 看一下 sandwich 的情况，此时 BW 处一条边的用时是 $m(hb/q)$。
3. 看一下直接解决的情况，此时一条边的用时是 $m(hb/(kh/q))$。

平衡后两条可知 $q=\sqrt{kh}$。此时是比较 $1/h+1/b$ 和 $hb/\sqrt{kh}=h^{1/2}b/k^{1/2}$。那么 $b$ 应该比 $h$ 小，否则该对换。因此是比较 $1/b$ 和 $hb/\sqrt{kh}=h^{1/2}b/k^{1/2}$，此时显然 $h=b$，得到 $1/h$ 和 $h^{3/2}/k^{1/2}$，平衡点为 $h=k^{1/5}$，效率为 $m/k^{1/5}$（实际上，我们在 $mk^{2/5}$ 时间内解决了 $k^{3/5}$ 的边）。

复杂度 $mk^{4/5}$。

#### 2506.00428

之前我们说，做一个大小是 $m$ 的 $h$-hop Reducer，需要 $h$-hop negative reach 是 $n/h$。

后来他们发现，可以只需要如下限制：对于每一个 $\eta\leq h$，$\eta$-hop negative reach 是 $n/(h/\eta)$。这是严格弱于之前的限制的。

$\forall$ 比较烦，但我们可以只对每个 $\eta=2^i$ 保证，这样就差一个 $2$ 的常数。

##### Modified Betweenness Reduction

那怎么推出 $R^\eta$ 呢？之前我们说到，可以用 $BW^{r+h}$ 和 $h$-hop sandwich 推出 $R^r$。但问题是，那里用的是 $\phi(u)=d^{r+h}(s,u)$。现在如果对于每个 $\eta$ 做一下，这就爆了。

那就取 $h$-hop 呢？注意到 $d^{r+h}(s,u)+d^{r+h}(u,t)$ 一定比 $h$-hop 的版本小，所以还是取第一项，然后就是 $d^r(u,x)-d^h(u,t)-d^h(s,x)$……但这样你就拼不起来了。

然后有人发现，可以直接把 $\max$ 改成 $\min$。现在之前的直觉都不对了，但我们算一遍：得到 $d^r(u,x)+d^h(s,u)+d^h(x,t)\geq d^{r+h}(s,x)+d^h(x,t)\geq 0$，好，它对了。

为什么呢？你让 $\phi(x)=-d^h(x,t)$ 也不差，因为根据 BW，这样会大于等于 $d^{r+h}(s,x)$。所以直接用后者又差不多是对的，但是需要再次中和一下 $u$ 到自己的部分。

假设我们用了 $h_0$-hop sandwich，那我们只需要对于每个 $2^i$，满足 $(2^i+h_0)$-hop betweenness 是 $n/(h/2^i)$。那个 Reduction 的复杂度是两个括号里面乘起来，所以差不多就是 $mh$——但如果 $2^i<h_0$ 就寄了。坏消息是，我们确实需要使用 $2^i$ 小的情况。所以考虑让 $h_0$ 是 log 级别的，或者我就直接写 $1$ 了。

那怎么把这么多 BW Reduction 一起做呢？那就真的一起做：每个会搞出一些额外的点，把它们全部放一起。复杂度 $mh+nh^2$。

##### New Hop Reducer

现在我们知道，对于每个 $2^i$，$2^i$-hop BW 是 $n/(h/2^i)$ 级别。不过 NR 很小有什么用呢？

有人曾经在 arXiv 上提了一个做法，但后来假掉了。那里面说，一条最短路经常在 $2^i$-hop Negative Reach 里面。

事实上，如果你的最短路一直是递减的话，那确实是对的：每一段 $2^i$-hop 的东西总距离为负，所以就全部在里面。但你的路径上 dis 可能是不断增加的，然后就寄了。
（我现在也天天被增加的情况卡，如果有人有idea解决如下形式的路径：每次走完负权边后的 dis 递增，可以联系我。）

但这里发现，第二种情况可能是能做的：如果我们能处理 $2^i$-hop 在 $R^{2^i}$ 里面的路径，也能处理走出去但是总和非负的路径，我们就能很好的解决整条路径，因为它总能被分成这样的若干段。

对于第一部分，它就是一个 $R^{2^i}$ 里面的 $2^i$-hop reducer。因此，我们考虑递归地构造这样的东西。但第二种情况怎么办？它是在 $R^{2^i}$ 里面走了一会然后出去，所以它自然也可以用 hop reducer 变成一步。但问题是，它可能走一下就出去了，这样用一个 hop 模拟它就太差了，达不到 hop reducer 的目的。不过，我们知道这样的路径总权值是正的，那有什么好处呢？

考虑一个 $R^{2^i}$ 里面的 $2^i$-hop reducer，我们给它分两层，第一层是原图，第二层是走一次负权边后到的东西。在这里面的路径可以看成走到第二层，再从第二层跳回第一层。我们现在把 $R^{2^i}$ 之外的点也加进来，放在第一层，从第二层连出来的地方就连到这里。这样的话，如果一个路径走了一半就出去了，它可以看成在上面到第二层，然后从那里回来。

考虑出去的那一步。假设从 $v$ 跳到了 $w$。如果到 $v$ 的距离是 $d^{2^i}(U,v)$，那走出去的总路径就应该是正的。那我们能不能不用一个 hop 模拟它呢？事实上，我们可以把那个负权边移到别的地方去：考虑删掉第二层跳回第一层的边，这样从第一层出发，通过离开 $R^{2^i}$ 的方式回到第一层时，总距离一定是非负的。此时我们可以快速求出最短路，得到 $\phi$（做法：以第一层为起点开始最短路）。然后把跳回来的边加回来，就只剩它们是负权边了。

这样的话，我们大概就得到了从 $R^{2^i}$ 的 $2^i$-hop reducer 推出任意更大的图的 $2^i$-hop reducer 方案。但是，如果 hop reducer 一不小心求出了真的最短路，然后上面到 $v$ 的距离小于了 $d^{2^i}(U,v)$，那好像又寄了。因此，我们需要微调这个 hop reducer，使得它不会让那个距离小于 $d^{2^i}(U,v)$。可以发现这样还是应该能模拟 $2^i$-hop。

怎么微调呢？这就涉及到你怎么构造这个 hop reducer。所以我们先来考虑怎么构造这个东西。每一步，我们已经有了一个 $2^i$-hop reducer，然后我们想造一个 $2^{i+1}$-hop 的。我们显然不能叠两层上一个 hop reducer，不然就爆了。但如果我们能很轻松地知道距离，那不如直接算出所有负权边端点的两两 $2^{i+1}$-hop 距离，那样可以直接造出 hop reducer：我们把图（的非负部分）复制两层，第一层到第二层连上这些边，然后自然就行了。

如果像这样构造，那造出来的东西似乎应该直接满足到 $v$ 的距离就是 $d^{2^i}(U,v)$。但是，你可能求最短路的时候一不小心求出来一个更好的，然后就炸了。所以还是得微调。但这个构造下，实际上很好正确地微调：考虑每条边 $d^{2^i}(u,v)$。我们希望满足，这条边接上一个在 $G^+$ 上走出 $R^{2^i}$ 的路径时必须是非负的。那么从所有走出 $R^{2^i}$ 的边开始倒着最短路，就可以知道该调多少。同时，这样调完显然还是小于真正的 $d^{2^i}(u,v)$ 的，所以不会影响事情。

最后一个问题是怎么求出下一组两两之间的距离。因为我们有上一个 hop reducer，所以你可以在上面跑 $2$-hop 解决问题。但每一轮图的大小是 $m/(h/2^i)$，所以在上面跑 $|U|$ 个点的话，到最后一轮复杂度就炸了。但如果你的路径真的经过了 $2^i$ 个 hop，那有一个好的处理方式：随机 $|U|/2^i$ 个边（还需要 $\log$，但是不管），那么你有很大概率经过这里面的一条。所以，从这些边开始向两边 $2$-hop，然后更新距离。复杂度 $m/(h/2^i)\cdot (|U|/2^i)+|U|^3/2^i=m|U|/h+|U|^3/2^i$。

这里会出现两次 $|U|^3/2^i$：第一次是这些点在 $|U|^2$ 条边上跑最短路，第二层是这些点更新距离。

但这样就只能处理真的经过了很多 hop 的路径，比如经过了 $[2^{i-1},2^i]$ 个。那更小的怎么办？我们把每一轮的都拿回来。如果第 $i$ 轮造的东西能够满足：

1. 对于走了 $[2^{i-1},2^i]$ 步且在 $R^{2^i}$ 里面的路径，用一个 hop 模拟它，然后
2. 对于走了 $[2^{i-1},2^i]$ 步后走出 $R^{2^i}$，用 $0$ 个 hop 模拟它。

那我们把所有的放一起，就能解决问题：如果它在某个 $2^j$ 步左右走出了 $R^{2^j}$，就用情况二，否则就到最后去用情况一。

这样就搞完了。每一轮的 $m|U|/h+|U|^3/2^i$ 求和，复杂度 $m|U|/h+|U|^3$。

现在复制一遍之前的分析。我懒了，不想分析 $R$ 是别的大小的情况了。

1. 新版 Betweenness Reduction 复杂度为 $mh+nh^2$。
2. 在 Sandwich 步骤，我们要么找到 $q$ 的 Sandwich，要么解决 $k/q$ 的边数。（注意 $h_0$ 是 log 级别的。）
3. Sandwich 构造是 $mh$，可以忽略。
4. 构造 Hop Reducer 是 $mq/h+q^3$。使用 Hop Reducer 是 $mq/h$，可以忽略。

首先我们忽略 $nh^2$ 这一项，然后再忽略 $q^3$。这样的话，

1. 看一下 sandwich 的情况，此时 Hop Reducer 处一条边的用时是 $m/h+q^2$（但我们忽略第二项）。
2. 看一下 sandwich 的情况，此时 BW 处一条边的用时是 $m(h/q)$。
3. 看一下直接解决的情况，此时一条边的用时是 $m(h/(k/q))$。

那自然 $h=q^{1/2},q=k^{1/2}$。因此复杂度就是 $mk^{3/4}+k^2$。

但这样在 $m\leq k^{5/4}$ 的时候已经不优了。此时需要降低 $q$ 重新调参。或者看成，求出一个 Sandwich 后，我们扔掉一些边，对剩下的继续做。

现在相当于求 $\min(1/h,q^2/m,h/q)$。让所有东西相等可以得到 $h=m^{1/5},q=m^{2/5}$。此时复杂度 $m^{4/5}k$。注意这个和之前 $mk^{4/5}$ 有一些微妙的差别。

这样合法当且仅当 $q\leq k^{1/2}$，算出来正好是 $m\leq k^{5/4}$。（这样算出来也一定得相同，因为都是说一项太大了需要变小）。

不过 $m$ 很小的时候，$nh^2$ 那一项也得特殊处理。可以发现换成 $h^3$ 就一定没有问题，但这里和之前又有一些不一样：之前是 $b$ 个点，每个点都往另一侧搞 $h$-hop 最短路，所以两两之间路径是 $2h$-hop 最短路。现在有很多种不同的点，第 $i$ 种有 $h/2^i$ 个，然后跑 $2^i$-hop 路径；此时全跑 $h$-hop 就变回 $mh^2$ 了。优秀的处理方法是把 $i$ 小的到 $i$ 大的路径放在大的 $i$ 那里处理，那里求出双向 $2\cdot 2^i$-hop 路径，然后给所有小的 $i$ 连边，因为这一定包含了小的 $2^i+2^j$。这样就还是 $mh+h^3$ 的。

#### 2511.12714 + 2511.18253

接下来发生了一些 parallel 的更新，然后它们可以全部合并起来，所以我放一起写了。

但有趣的是，大家都注意到了同一件事：有一些步骤可以优化成跑最短路，然后之前的算法可以看成直接 $mk$ 最短路（回顾：$k$ 是负权边数量）。但我们现在有更好的最短路了，所以自行递归一下，就有了更好的复杂度。

这里可能会出现一些 $\tilde O$ 大战。具体来说，很多递归有 $\log\log$ 层（比如每次递归 $k$ 变成 $k^c$），每一层乘上一个 $\log$。此时会有超过 $\tilde O$ 的东西，但我也不想写出来。

##### Hop Reducer Improvements

考虑最初的分层 hop reducer。一条 $h$-hop 的路径在上面跳了不超过 $h$ 次，然后通过一条负权边下来。直接的构造有 $|U|$ 条负权边。但因为你是 $h$-hop 的路径，所以随机选 $|U|$/h$（某些地方需要 $\log$，但我又懒了）个点，在那些点上放下来的边，就可以让这条路径下来。

为什么概率对呢？我们只需要考虑 $n^2$ 条最短路，每一条都能够下来就行。

那么现在通过 hop reducer 搞出最后的最短路的过程就相当于，有一个 $m$ 大小的图，和 $|U|/h$ 条负权边……直接做还是 $m|U|/h$，但现在你就可以用最短路来优化它了。

假设我们可以 $mk^\alpha$ 求最短路，那这东西就可以 $m(|U|/h)^\alpha$。然后复制一下计算：

1. Betweenness Reduction 复杂度为 $mhb$（第二项不要了，不重要）
2. 在 Sandwich 步骤，我们要么找到 $q$ 的 Sandwich，要么解决 $kh/q$ 的边数。
3. Sandwich 构造是 $mh$，Hop Reducer 构造是 $mh$，可以忽略。
4. 使用 Hop Reducer 是 $m(1+h/b)(q/h)^\alpha$。

所以，

1. 看一下 sandwich 的情况，此时 Hop Reducer 处一条边的用时是 $m(q/h)^{\alpha-1}(1/h+1/b)$。
2. 看一下 sandwich 的情况，此时 BW 处一条边的用时是 $m(hb/q)$。
3. 看一下直接解决的情况，此时一条边的用时是 $m(hb/(kh/q))$。

如果 $h<b$，那么交换 $h,b$ 更优。所以 $h\geq b$。现在第一项是 $h^{1-\alpha}\cdot ...$（因为 $1/b$ 是右边主项），第三项和 $h$ 无关，第二项是 $h$ 乘上一些东西，所以 $h$ 应该小一点。那么 $h=b$。

现在第一种情况是 $q^{\alpha-1}h^{-\alpha}$，后面是 $h^2$ 除以 $q$ 和 $kh/q$。因此 $q$ 应该大于 $kh/q$，否则交换使得第一项更优。然后是 $q^{1-\alpha}h^{-\alpha}$ 比上 $qh/k$。固定 $qh$，我们想最小化 $q^{1-\alpha}h^{-\alpha}=q/(qh)^\alpha$——好，$q$ 又应该尽量小，因此 $q=\sqrt{kh}$，现在比 $k^{(\alpha-1)/2}h^{(-1-\alpha)/2}$ 和 $h^{3/2}k^{-1/2}$，得到 $k^{\alpha}=h^{\alpha+4}$，$h=k^{\alpha/(\alpha+4)}$。然后 $q=k^{(\alpha+2)/(\alpha+4)}$。最后 $h^2/q={(\alpha-2)/(\alpha+4)}$。从而 $\alpha=1+(\alpha-2)/(\alpha+4)=(2\alpha+2)/(\alpha+4)$。这是二次方程 $\alpha^2+2\alpha-2=0$，解得 $\alpha=\sqrt 3-1$。也就是说，你一直这样递归下去，递归很多层，就是 $mk^{\sqrt 3-1}$ 的。

##### Betweenness Reduction Improvements

最近有人发现，一种 $0.5$-hop betweenness：计算有多少条负权边满足 $s$ 到 $t$ 且只经过这条负权边存在负权路径。这样相当于随机一些负权边，然后向所有点连 $d^0$ 的路径——不过你根本不需要连这么多边，因为 $G^+$ 就可以模拟这件事。因此，你只需要从复制连回自己，然后剩下的交给 $G^+$。这甚至等价于直接随机保留一些负权边。

那一般的 hop 怎么办？考虑模拟 $d^h$，那就像之前那样，两边搞 $d$-分层图。具体来说，从 $G^+$ 拉一个 $h$ 层的分层图上去，然后从那些选到的负权点跳过去，再拉一个 $h$ 层的分层图回来。

不过分层图也有负权边啊？但这是个分层图，我们可以给两层中间加一个权值，然后在另外一层减掉。这样可以集中到中间随机边的那一层上去。

这样的话，这个图有 $mh$ 条边和 $b$ 条负权边，那我们就从 $mhb$ 变成了 $mhb^\alpha$（同时我们也不用考虑万恶的 $nb^2$ 了）

然后可以再算一遍，但是我懒了。不过直接在这里递归的话还打不过 $3/4$。另一方面，这里每次生成的图里面负权边都非常少，所以都是 $mk^{3/4}$ 的情况。用那个的话，我们就是把 BW 变成 $mhb^{3/4}$。然后每轮是

1. 看一下 sandwich 的情况，此时 Hop Reducer 处一条边的用时是 $m(1/h+1/b)$。
2. 看一下 sandwich 的情况，此时 BW 处一条边的用时是 $m(hb^{3/4}/q)$。
3. 看一下直接解决的情况，此时一条边的用时是 $m(hb^{3/4}/(kh/q))$。

那么 $q=\sqrt{kh}$，我们现在比较 $h^{1/2}b^{3/4}/k^{1/2}$ 和 $1/h+1/b$。再放送：显然 $h$ 该大于 $b$，然后比较左边和 $1/b$，那显然 $h=b$。因此是 $h^{5/4}/k^{1/2}$ 对上 $h^{-1}$，得到 $h=b=k^{2/9}$，复杂度显然就是 $mn^{7/9}$。

##### Combining Together

显然上述两个优化是独立的，所以一起用。假设我们有 $mk^\alpha$ 的最短路，那么

1. Betweenness Reduction 复杂度为 $mhb^\alpha$。
2. 在 Sandwich 步骤，我们要么找到 $q$ 的 Sandwich，要么解决 $kh/q$ 的边数。
3. Sandwich 构造是 $mh$，Hop Reducer 构造是 $mh$，可以忽略。
4. 使用 Hop Reducer 是 $m(1+h/b)(q/h)^\alpha$。

所以，

1. 看一下 sandwich 的情况，此时 Hop Reducer 处一条边的用时是 $m(q/h)^{\alpha-1}(1/h+1/b)$。
2. 看一下 sandwich 的情况，此时 BW 处一条边的用时是 $m(hb^\alpha/q)$。
3. 看一下直接解决的情况，此时一条边的用时是 $m(hb^\alpha/(kh/q))$。

抄一遍分析（你也可以先相信再相信）。首先容易发现 $h=b$，这里和上面一样。

现在第一种情况是 $q^{\alpha-1}h^{-\alpha}$，后面是 $h^{1+\alpha}$ 除以 $q$ 和 $kh/q$。因此 $q$ 应该大于 $kh/q$，否则交换使得第一项更优。然后是 $q^{1-\alpha}h^{-\alpha}$ 比上 $qh^\alpha/k$。左边是 $q^{2-\alpha}/(qh^\alpha)$。因此固定 $qh^\alpha$ 的时候，我们希望 $q$ 尽量小。那么 $q=\sqrt{kh}$。

然后第一项是 $k^{(\alpha-1)/2}h^{(-1-\alpha)/2}$，第二项是 $h^{(1+2\alpha)/2}k^{-1/2}$。比对得到 $k^\alpha=h^{2+3\alpha}$。从而 $h=k^{\alpha/(2+3\alpha)}$，$q=k^{(1+2\alpha)/(2+3\alpha)}$。然后 $h^{1+\alpha}/q$ 就是 $k^{(\alpha^2-\alpha-1)/(2+3\alpha)}$。

那么 $\alpha=1+{\alpha^2-\alpha-1}/(2+3\alpha)$，直接得到 $2\alpha^2=1$，所以复杂度是 $mk^{\sqrt 2/2}$。非常好看的复杂度。

##### ``New Hop Reducer'' Improvements

第一个注意点是，对于一个很小的 $2^i$，我们可以通过最短路暴力算出 hop reducer——这里图大小 $2^im/h$，负权边数 $|U|$。所以暴力的话，应该只能在 $m|U|/h$ 里面解决平凡的 $i$；但用一个 $mk^\alpha$，我们就可以解决不平凡的 $i$。

然后有几个观察：

1. 如果 $i$ 变大了，这就意味着我们在之前 betweenness 的要求里面，不再让 hop 数从 $1$ 开始，而是从 $2^i$ 开始。这样的话，我们就可以让 $h_0=2^i$，从而拿一个更大的 sandwich（相当于白送 $2^{i/2}$ 的效率）
2. 之前的构造还有一个直接优化：我们不把 $|U|^3/2^i$ 的枚举更新做出来，而是把整个 $|U|\times |U|/2^i\times |U|$ 的图扔进去。这样的话，下一轮跑距离的时候，有 $|U|/2^i$ 个点在上面跑距离。这样我们就把 $|U|^3/2^i$ 变成了 $|U|^3/(2^i)^2$。
3. 还有一个小优化：我们把 Betweenness 也用上面的做法改掉。这里细节较多，但我懒了，因为我真会。改完之后，$\eta$-hop 的 betweenness 可以变成 $n/(h/\eta)^{1/\alpha}$（因为 BW 现在是 $mhb^\alpha$ 的，但有 $h$ 很大，$b=O(1)$ 的情况，我们不能改进复杂度，但可以让 $h$ 小的时候 $b$ 更大）。这可以让 $i$ 小的时候图更小，然后我们可以选一个更大的 $2^i$。

我还没算完，下次再写。