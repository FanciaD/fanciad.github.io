---
title: '[paper] Planar SSSP'
date: '2025-08-23 09:33:55'
updated: '2025-08-23 09:33:55'
tags: Fancia
permalink: Ibara/
description: Planar SSSP
mathjax: true
---

写这个纯粹为了证明自己活着。

虽然感觉活着这样坐牢还不如回去睡觉。

### (Negative Weight) SSSP on Planar Graphs

平面图有什么用？有一个不怎么经典的结论：

#### Planar Separatpr Theorem

结论：我们可以删掉 $O(\sqrt n)$ 个点，将平面图分成两部分，使得每部分大小不超过 $2/3$。

为了简便，我们先假设图里面除了外侧面以外都是三角形。这件事只需要给每个面里面加点边，然后用三角剖分（可以 $n\log n$，但那又是一大堆阴间东西）

##### Planar Splitting and Duals 

首先考虑如何把一个平面图——它的所有三角形分成两部分。从这些三角形的角度，我们考虑 Dual Graph——每两个三角形之间连边当且仅当它们共用了一条边。

然后我们希望把 Dual Graph 分成两部分，此时需要拆掉的就是两边共用的边——Dual Graph 上面的割。

我们考虑一个最简单的情况：外侧面是一个 $n+2$ 边形，然后有 $n$ 个面。这相当于说中间没有别的节点。此时可以发现，这个对偶图必定是一棵树：数数可知中间只有 $n-1$ 条边，同时这东西连通。

那这个的分割是容易的：因为每个点度数只有 $3$，根据边分治结论，可以找到一条边删掉，划分为 $1/3-2/3$ 的两块。对偶回去就是可以找到一条边，连同点删掉后两侧是独立的两部分。

那一般情况呢？可能图里面边很多，此时不一定能做。但如果我们知道这个图有很好的性质，那我们就会做。后面我们会用到这一点。

##### the Proof

考虑从一个点开始 bfs。显然，bfs 后边只在相邻层之间，因此删掉任意一层都是一个 Separator。

我们假设层数很多。如果至少有 $O(\sqrt n)$ 层，我们就可以找到一层，使其只有 $\sqrt n$ 个点。

那如果层数很少呢？考虑从外向内建对偶图，那么对偶图的边一定是从外层往内层的边，以及同一层一圈之间的边。我们优先保留外进内的边，构造一棵生成树，做之前的划分。此时需要考虑两块之间的边数，但因为我们建树的方法，可以感受到应该每一块在一圈里面是连续的。从而，我们只需要每一层删掉常数个点，就可以把两块在每一圈上分开。

第一种情况还有一些细节来保证一侧不大：具体来说，如果点数 $[1/3,2/3]$ 部分有一层很小我们就真的做完了。否则，我们向两侧扩展，删掉两个小的层后，中间部分每一层都至少 $\sqrt n$ 个点。此时如果中间不大于 $2/3$ 就做完了（中间不小于 $1/3$）。否则，中间部分只有 $\sqrt n$ 层，然后使用第二种情况的算法解决问题。

#### From Separators to Shortest Paths

我们先来看一个简单的情况:

##### Simple Cases

这甚至是一个 ACM 比赛题目：[NEERC15D Distance on Triangulation](https://vjudge.net/problem/Gym-100851D)。这里就是之前说的，三角剖分内部没有额外点，对偶图是一棵树的情况。

此时，按照上面的方式不断递归，我们得到了一个树形结构，每一块只有两个点和外面可能有关，然后每一块向下分成了两块。

那么，对于剩余部分，一块内唯一有用的信息就是这两个点之间的距离。那么考虑从下往上求这个距离，每一步里面，我们求出了下面两块上来这两个点之间的距离，然后需要往上合并到新的点……此时我们需要询问新的点在块内的距离。

那用这个信息，怎么询问两个点的距离呢？这很简单，路径从一块出来只有两个点，我们只需要知道起点 $s$ 在每一层所在块内，到两个分界点的距离。然后不断向上转移，每一层需要用到下一次四个分界点到上一层两个分界点的距离。$t$ 的部分类似。最后枚举在哪一层合并。这样就回答了每一层如何求出这些距离。

（好像当年有更简单的写法，但我懒得翻了。）

最后，我们还可以求一个最短路。考虑一块内的最短路需要啥，那显然只需要知道两个分界点的信息，或者只需要知道这两个点向外的距离。那么从上往下拿进来这两个点在外面的距离即可。

##### General Cases

一般情况就是把两个分界点换成了 $\sqrt n$ 个分界点。那么，我们类似的求出这些点之间的两两距离即可。

为了简便，我们可以假设上一层的分界点在下一层还是分界点。可以证明这样不会坏事，最多常数差几倍。这样就不需要做那个每层递归询问的事了。

考虑复杂度，注意到每块是分别的 $\sqrt n$，所以同一层不同的两两距离加起来是 $O(n)$ 个。但是每层往上是 $\sqrt n$ 个点的 APSP，所以直接做可以获得 $\tilde O(n^{1.5})$ 的复杂度。

#### Monge Array and Better Complexity

众所周知，给你一个任意的两两距离，APSP 是基本上做不到更快的——除非你搞个特大新闻。

但平面图最短路是特殊的东西：注意到如果两条路径相交，那么可以对换。由此可以发现，如果我们在边界的环上取出两个区间，那就有 $d(l_1,r_1)+d(l_2,r_2)\geq d(l_1,r_2)+d(l_2,r_1)$。换句话说，这东西有四边形不等式。在环上的话，一种简单的处理方式是 cdq 分层。

那么考虑 Bellman-Ford，每一轮我们要做的是转移一层，那就是转移一遍四边形不等式。根据 OI 常用技术，随便写一个决策单调性就是一个 log 的，甚至可以线性（SMAWK）。

不过这样搞的话，每个点做一次还是三方的复杂度——因此我们考虑模拟 Dijkstra。这个的区别是，我们每次加入一个转移点，然后问下一个能转移到的最小值。如果只加点的话，我们可以魔改经典的决策单调性的单调栈做法：维护每个点的最优转移区间，然后加点时从新加入点开始，向两侧尝试更新最优转移点。然后需要求出最小值，所以每个点出发的距离先维护个序列区间最小值结构。最后还需要把这个点删掉，这很恶心。不过根据 Dijkstra，拿出去的点就不会再被更新。所以直接在那一个线段树上删掉，之后就不会再改了。这样就是单次线性的。

如果有负权，就第一个点 BF，后面 Dijk。

这样做两点距离是 $\tilde O(\sqrt n)$ 单次询问（用之前 BF 给的权值）的。