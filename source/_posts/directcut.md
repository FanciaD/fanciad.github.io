---
title: '[paper] Directed Mincut'
date: '2024-12-08 18:41:01'
updated: '2024-12-08 18:41:01'
tags: Fancia
permalink: Asuiro/
description: Directed Mincut
mathjax: true
---

### Directed Mincut and s-cut

有向图上的 $s$-cut：找 $s\in S,T=V\setminus S$，最小化 $S\to T$ 的有向割。有向图上这种东西是不对称的。



#### S-cut, Arborescence Packing, Matroids

考虑一个广义的 Dual Problem：什么是保证 $cut(s)\geq 1$ 的最小单元？

这需要满足，对于任何一个包含 $s$ 但不是全集的点集，它向外的割都不是 $0$，即有一条连出去的边。那沿着这些边走，可以发现答案是以 $s$ 为根的一棵外向树，一般叫做上面那个词。

更一般的，我们有如下定理：

>  考虑无权情况（整数权情况类似），一个图的 $s$-cut 等于我们最多能把边拆成多少个以 $s$ 为根的外向树。

我们首先证明一个简单版本的性质：

> 一个图的 $s$-cut 等于最大的 $k$ ，使得我们能找到 $k$ 个生成树（无视边权），同时 $s$ 入度为 $0$，其它点入度为 $k$。

可以发现这是一个拟阵交，因此直接抄一手传统拟阵交做法：

维护一个边集 $S$，表现为 $k$ 个生成森林，每轮尝试加边，遵循如下过程：

1. 初始标记一条不在 $S$ 中的边，当且仅当它指向的点入度还不是 $k$。
2. 一条不在 $S$ 中的边可以作为增广路的结束，当且仅当它可以加入到某个森林里面。
3. 不在 $S$ 中的边向在 $S$ 中的边连边，当且仅当替换后在生成树的拟阵里面。这里我们只用一个简单的判定：可以把它放到某个生成森林里面，然后从环上拿掉一条边。
4. 在 $S$ 中的边向不在 $S$ 中的边连边，当且仅当替换后在入度拟阵里面。这里我们简化为两条边指向同一个点。

然后按照拟阵交惯例，找一个可以作为开始的边，一直增广，直到找到一个可以作为结束的边，然后替换。要求找最短路径，所以要 bfs。

为什么可以简化？首先第二个是显然的：如果我们可以连到另外一个边，那本来那边指向的入度就小于 $k$，我们就不需要前面这一段（实际上正确性也是由最短增广路保证的）

那第一个为什么对？我们证明如下性质：

1. 在每一步后，所有访问到的边可以被描述为某个点集 $A$，使得访问到的内部边是每个生成森林在 $A$ 上的导出子图，外部边是所有指向 $A$ 的边。同时，$A$ 在每个生成森林上连通。

证明：对 bfs 归纳。往外走就是 $A$ 导向指向 $A$ 的其它边，然后往里面走是所有其它边把树上路径加进来。注意到加进来的时候有一边已经在里面了，所以还是连通的。

2. 如果有一步扩展失败，那当前的 $A$ 就是一个 $<k$ 的 $s$-cut。

证明：根据说明的过程，停下来的时候，所有当前没有选择的连向 $A$ 里面的边都是从 $A$ 里面指过来的。考虑 $A$ 里面每个点的入度，因为它们在每个生成树里面连通，这就贡献了 $k(|A|-1)$ 的入度，又因为我们的起点在这里面，所以有一个点本来差一个入度，因此在已经选择的边里面，它们最多有 $k-1$ 个入度从外面过来。（如果 $s\in A$，那么它会减少 $k$ 个入度，这不可能）。又因为其它的边都是从里面指过来的，所以这就是一个 $<k$ 的割。



因此如果没有小的 $s$-cut，这样就一定成功。这就够了。



然后我们说明：给一个这样的边集，我们可以从里面分出 $k$ 个外向树。

考虑一次分出一个。我们维护一个外向树 $A$ 和 $k-1$ 个无向生成树。每次扩展的时候，如果能直接用就加进来，否则从无向生成树里面换，用上面的增广方式。相当于删掉这条边，然后重新增广。

然后我们需要说明一定能增广出来。此时又有一车结论：

1. 如果增广失败，考虑把这条边加回来，但还是从这个点增广，能访问到的边集不变。（注意上面的增广从来没看过点的入度）

证明：在删掉的树上看。增广失败说明我们本来就到不了另外那边，所以加回来也没用。

2. 如果增广失败，那整个过程中必然访问到了另一条 $A\to S\setminus A$ 的边。

证明：否则的话，当前访问到的（换个字符）$B$ 里面，每个点还有一个入度没有用，它们只能从 $B$ 自己连过来。然后数 $B$ 的入度：生成树给了 $(k-1)(|B|-1)$，上面的入度给了 $|B|$，那么 $B$ 就是一个 $k-1$ 的割，这不对。

3. 在把边加回来再从这跑的过程中，如果跑到另一个边，那从那里开始走到的是当前子集。

证明：显然。

但这说明：每个边出发不会走回自己，能走到别的点，到的点走到的是自己的子集，那一路递降必定有矛盾。



所以存在合法构造。



#### MWU for Covering and Packing

考虑一个最简单的 Set Cover 例子。根据经典结论我们有 $\log n$ 倍的近似。它也可以看成这样：

设最优解为 $C$，如果我们在 $C$ 里面随机 $|C|\log n$ 个集合，那有非零概率每个元素都被覆盖至少一次。

依次选集合，记 $f(u)=(1-1/|C|)^k$ 表示当还剩 $k$ 个集合没有选的时候，后面随机的情况下它没被选到的概率（如果前面覆盖过了，则 $f(u)=0$）每一轮我们选一个集合，最小化 $\sum f(u)$。那么：因为在 $C$ 里面随机选一个期望保持，那么我们总能选到一个使得期望不增。这样到结束就是胜利。这样并不需要知道 $C$。



然后我们来看一般的 Packing Problem：有若干个向量 $x_i$，选一些出来做平均，使得每一维最大值尽量小。定义 Width $\omega$ 是 $x_i$ 中最大值除以最小值的商（等会就给它 Normalize 到 $[0,1]$）。

考虑如果有一个最优解，然后我们按照最优解的权值作为概率直接随机，那根据 Hoeffding，出来大 $\epsilon$ 的概率不超过 $\exp(n\epsilon^2/\omega^2)$。

根据更 nb 的 bound 方法，可以得到差不多 $\exp(n\epsilon/\omega)$。所以我们只需要 $O(\omega\log m/\epsilon)$ 次操作。

考虑这东西的证明。根据经典的那一套，我们取一个 $x$，然后把每一项比较变成 $\Pr[(1+x)^{\sum y}/(1+x)^{(1+\epsilon)(E\sum y)}\geq 1]$，然后左边变回 $1+yx$，但也可以放缩一半，到 $\prod (1+y_tx)$，表示每一步加上去的 $y$。

这里 $E\sum y$ 都是相等的，那么每个东西的权值就是那个 $\prod (1+y_tx)$。

如果部分放缩一下，那每一步的目标就是最小化 $\sum y'\prod (1+y_tx)$。这样就得到了合理的 MWU：

记权值为 $y_i$，每轮最小化 $\sum f_iy_i$，然后给 $y$ 乘上 $1+f_ix$。$x$ 需要正确的设定（实际上在Raghavan’s Bound 里面就是 $\epsilon$）

注意到每一轮最小化的东西显然是最小树形图，最好的做法是 $O(m+n\log n)$。

Note. 实际上想法不难：考虑每个点选最小出边，那么我们得到一个环。可以证明任何情况下环上选 $k-1$ 条边最优（否则的话断掉外面的然后用环上拼接）。那我们可以把环缩成一个点，然后对应调整环上边权。高明的实现可以做到单 $\log$。



那这个有什么用？我们可以通过 $O(\omega\log m/\epsilon)$ 个最小树形图的平均结果近似最优的最小树形图覆盖。为了写成 Packing Problem，我们实际上选一条边的时候给它 $1/w$ 的权值，这样最后就是总和不超过 $1$ 的 Packing。然后总和和平均可以换：此时如果最小 $s$-cut 是 $c$，则存在一个 $1/c$ 平均的 Packing。然后我们选了 $d$ 个树形图，那它们加起来的 $(1-\epsilon)c/d$ 倍应该不超过原边权。

也就是说如果我们找到真正的 $s$-cut，那它和这 $d$ 个树形图的交应该不超过 $(1+\epsilon)d$ 条边，不然乘完倍数就爆了。又因为每个树形图上一个割至少一条边，因此：对于 $1-\epsilon$ 比例的图，最小割在上面只割了一条边。



#### Using Arborescence

这意味着最小割在树上是一个连通块。

点分。固定根的版本是一个网络流。



然后分析复杂度。注意到常数比例的树是好的，因此我们可以随机 $O(\log n)$ 棵树，然后就是 whp 对。

所以我们就 MWU 地找到 $O(\omega\log m/\epsilon)$ 个树形图，然后随机 $O(\log n)$ 个跑点分。

一切看起来很对，但问题是，$\omega$ 是啥？可以发现边权差很多就寄了。



好消息是，上述最后一步已经开近似了，所以我们拿一个 Approx 的 Cut Sparsifier 来做也是对的。这就非常有趣：我们能用一个近似的 Sparsifier 做 Exact 的问题。

因此我们需要：



#### Partial Sparsification, Randomized Rounding

考虑如何降低边权。

一个在背包近似里面常见的东西：选一个 $B$，把所有权值随机到附近 $B$ 的倍数。为了合理，设 $y\in [kB,(k+1)B]$，那我们找一个随机到两个端点的概率，使得期望还是 $y$。

按照常理，我们需要说取整后一个割的边权和原来大概率差的不多。坏消息是我们根本不知道割有多少边，然后传统的 Chernoff 里面边数不能太小。但我们再给它来一点 Additive Factor（边数小的时候很有用），那就可以有

> Thm. 给若干个 $[0,1]$ 变量，则 $\Pr[\sum r_i\in ([1\pm \epsilon]\sum y_i)\pm \gamma]\leq 2\exp(-\epsilon\gamma)$。这个界和变量个数完全无关。

根据常见套路，我们考虑 $\epsilon=O(1)$ 或者 $O(1/poly\log)$。这里不是 $0/1$ 变量，所以还会除一个 $B$，就是 $\exp(-\epsilon\gamma/B)$。

考虑一下会发生啥。假设我们知道了最小割的权值范围，我们就可以设定合理的 $B$。如果我们最后要 $1\pm O(\epsilon)$ 倍的近似，那最后的边权总和需要是 $\gamma/\epsilon$，那下取整之后就是 $(\gamma/B)/\epsilon$ 的总边权。如果我们要直接解决问题，我们就需要 $\gamma/B=\Omega(n/\epsilon)$，那搞完总边权就是 $n/\epsilon^2$……但这看起来没什么用。

因此我们定义 **Partial Sparsification**：我们保证对于很小的割（$|T|\leq k$）我们都能近似，这样如果最小割很小那新的图上算出来的还对——但这就还需要满足第二点性质：对于很大的割，它们的值不会太小。

Note. 对于 Undirected Graph 上面的东西直接就可以了，因为 Karger's Algorithm 那一套可以说明 $\alpha$-approx Mincut 数量是 $n^{2\alpha}$ 的。

如果只需要满足第一点性质的话，我们就只需要 $\gamma/B=O(k\log n/\epsilon)$，因为这样就能 Union Bound 所有 $O(n^k)$ 个割。这样看起来很好：我们最后最小割的边权变成了 $O(k\log n/\epsilon^2)$。

但我们还需要让大的割不能太小。注意到我们的问题是 $s$-cut，考虑直接 $s$ 向每个点连一条边，边权是 $\epsilon\lambda/k$，其中 $\lambda$ 表示最小割的边权。这样对于小的边权只是加了 $\epsilon$ 倍。然后对于一个大小是 $c$ 的割集，它实际上大于 $1+2\epsilon$ 但被搞成了很小的概率是 $\exp(-(c/k)*k\log n))=O(n^{-c})$，所以这就可以 Union Bound 起来（放大一点点常数）。

这样的话，我们满足了如下性质：

1. 如果有一个最小割满足 $|T|\leq k$，且我们猜了一个足够近似的 $\lambda$，那这样搞完，这个割的权值和原来差距不超过 $1\pm \epsilon$，边权它的边权限制只有 $O(k\log n/\epsilon^2)$：我们先确定 $\lambda=\gamma/\epsilon$，然后再确定 $B$。 
2. 同时，whp，对于任何一个很小的割（$1+\epsilon$ 倍），它原来也只是 $1+O(\epsilon)$ 倍。

这样的话，我们就可以在先新的图上做最小割，然后就把任意边权变成了整数边权，且割的权值只剩 $O(k\log n/\epsilon^2)$。

为什么我们可以只考虑 $k$ 小的情况？不然的话，随机 $n/k\log n$ 次单点作为 $t$，然后跑 $s-t$ cut。



再来一次，我们现在有两种情况：

1. 如果最小割另外一侧大小 $k$ 很大，那直接随机点跑网络流，复杂度 $O(F(m,n)\cdot n/k)$。
2. 否则，先跑上面的 Rounding，此时 $w=k\log n/\epsilon$，所以总共就是 $O(k\log^2 n/\epsilon^2)$ 个树形图。这两步 $\epsilon$ 可以是常数，此时得到 $\tilde O(mk)$。然后再跑网络流，得到 $\tilde O(F(m,n))$。



因此总的复杂度是 $\tilde O(mk+F(m,n)\cdot n/k)$。



还有一个小优化：注意到我们只要 $k$ 个点的割，那如果一个点入度大于 $k\log n/\epsilon^2$，它就不可能在右边，从而可以把它合并到 $s$ 上。这样边数剩下 $O(nk)$。所以复杂度也可以是 $\tilde O(nk^2+F(m,n)\cdot n/k)$。



也可以对 $F(m,n)$ 部分改用 Sparsifier，这样会得到近似算法。大概是 $\tilde O(n^2/\epsilon^2)$



还有一些观察：考虑直接对着 $O(k\log n/\epsilon^2)$ 部分跑网络流会发生啥？一个关键是我们有每个 $s\to i$ 的边，那么只有 $O(k)$ 条边会被填满。所以如果**反过来**跑 Ford-Fulkerson，那么每次走 $O(k)$ 个点之后就会停。那么根据某种意义上的 Local Flow……

Paper Ref: 2111.08959