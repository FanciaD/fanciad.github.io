---
title: Algorithm Design 笔记
date: '2023-10-13 12:49:03'
updated: '2023-10-13 12:49:03'
tags: Fancia
permalink: Yuvislonging/
description: Algorithm Design
mathjax: true
---

### Algorithm Design / Note

#### Day 0(9/17)

我们从一个简单(???)的问题开始感受算法。



###### Problem

考虑一个路由器，它有 $n$ 个输入端口和 $n$ 个输出端口。每条消息从一个输入端口 $s_i$ 进入，它有一个指定的输出端口 $t_i$。

端口有流量限制。每个单位时间内每个端口最多输入/输出一条消息。为了避免流量限制造成的大量丢包，常见的实践是路由器内缓冲区(buffer)。为了简便这里认为 buffer 是无限大的。



一个简单的模型是只有输出 buffer，每个时刻每个端口进入的消息直接根据输出端口到达对应的输出 buffer。然后如果一个输出端口 buffer 内有消息，则选择一个输出。为了简便这里也不关心输出的具体是哪一条消息，而是只关心这个端口这个时刻是否输出了消息。

显然在只考虑流量限制的情况下，这个模型的延迟是最小的：所有消息的等待时间之和一定是最小的。简单证明：考虑在每个端口输出的消息，上述模型保证了能输出一定有输出，因此不可能更早地输出。



但这个模型在实践上会遇到一些问题。输入消息的移动也需要时间。因此考虑如下输入/输出 buffer 模型：

额外有 $n$ 个输入 buffer，每个时刻每个输入 buffer 最多增加一条消息。定义一轮处理操作为选择若干条输入 buffer 中的消息，满足选出的消息不共用任何端口（输入或输出），然后将这些消息移动到输出 buffer。输出 buffer 的情况不变。

显然这个模型更弱，因此我们的问题是：能不能让这个模型做到像之前一样最优。

但可以发现每个时刻只做一轮操作是不可能行的：一个反例是两个时刻，消息分别是 $\{1\to 1,2\to 1\},\{1\to 2,2\to 3\}$。如果按照之前的模型，两轮就可以发出所有消息。但新的模型中第一轮只能移动一条消息（只有一个目标点），第二轮最多移动两条消息（只有两个源点），因此不可能达到最优。



因此，最终的问题是：求出一个最小的 $k$，使得在每个单位时刻做 $k$ 轮操作的情况下，新的模型可以永远（无限运行下去）做到最优。例如，显然 $k=n$ 是可行的：将输入的每条边分别拆过去即可。

这里只关心 $k$ 的增长或者取值，决策的复杂度都是次要的。



###### Sol

非常震撼.jpg（根本想不到啊）



可以证明最小值是 $\mathbf{2}$。显然之前已经证明了 $1$ 不行，只需要构造让 $2$ 可行。

首先考虑如何描述状态。显然需要记录之前输入 buffer 中留下来的信息，然后容易发现操作满足要求当且仅当每个时刻中任何一个没有输出的端口满足输入 buffer 中没有指向它的信息。同时还需要记录当前每个输出 buffer 中有多少还没输出的信息。

但这样的状态显然不能描述合法性：如果左边一个 buffer 塞满就不合法了。但为了证明存在合法方案我们需要证明不会访问到这样的状态。因此我们需要找到一些限制，使得满足这些限制就一定合法，且上一时刻满足这些限制则下一时刻可以合法操作后仍然满足限制。



找限制是困难的。显然左侧部分每条消息都需要考虑。还可以发现右侧剩余消息数量也需要考虑（显然右侧可以关系到合法性）。而左侧有一条 $s\to t$ 和很多条 $s\to t$ 看起来还不一样。



Solution: 考虑将输入 buffer 排成可以任意插入删除的序列。对于每个在输入侧的消息，定义 $V(p)=Res(p)-In(p)$，其中 $Res(p)$ 表示 $p$ 的目标端口当前输出 buffer 中的消息数量，$In(p)$ 表示输入 buffer 中 $p$ 前面的消息数量。

那么可以发现，如果输出时每条输入侧消息满足 $V(p)\geq 1$，那 $p\to Res(p)\geq 1$，从而能输出就一定会输出，这就合法了。

因此考虑将限制设为 $\forall p\in Input, V(p)\geq 1$。这显然合法，然后考虑能不能达到。

显然输出相当于让每条剩余消息的 $V$ 减一。对于输入，考虑每条消息加入到输入 buffer 的开头，那么也是让之前的所有消息 $V$ 减一（$In$ 加一）。那么每轮操作需要让消息的 $V$ 增加。



因此考虑做到如下结果（根本想不到！!1）：

找出一个剩余消息的集合，满足一轮操作的限制（输入到输出的匹配），且这样移动后剩余每条消息 $V$ 至少加一。



接下来的部分就很直观了。考虑看成输入到输出的匹配。可以发现如果一条消息的输出端被匹配到了那么 $Res+1,V+1$，如果输入 buffer 拿出去的消息在它前面那么 $In-1,V+1$，因此不行的情况当且仅当它的目标端口没有被匹配，且它所在输入 buffer 中拿出去匹配的消息在它后面。

只需要考虑去除这种情况。很容易想到（这次是真的）只需要将匹配权值设为 $In(p)$，然后求最小权值匹配。因为出现之前的情况时改用之前消息匹配就能严格减少 $In(p)$，因此任一最小权匹配一定满足条件。

那么考虑每一单位时间按照 $In(p)$ 求任一最小匹配，然后做两次。此时如果操作前每条剩余消息 $V\geq 1$，那么加入后每条消息 $V\geq 0$（加入的消息也是 $V\geq 0$，因为每个输入 buffer 只有一条所以不会有在它前面的），然后两轮操作做到 $V\geq 2$，再输出一次回到 $V\geq 1$。这样就可以无限运行下去了。

这样在 $k=2$ 内做到了问题。每一轮只需要做带权匹配，这显然是 $poly(n)$ 的，这在大部分分析中已经够了（好像可以 soft n^2，但是没啥意义）。

Now we are done.



#### Day 1-3(9/18-9/20)

Chapter VIII -  NP-Completeness

从直觉上这些东西是为了解决计算复杂性：polytime解决问题是好的，但有一堆问题人们不会确定性 polytime 解决，还证不出来不能 poly 解决（复杂度下界太难了）。

但人们发现能解决一个就能解决其它的，因此人们搞出了一堆 Complexity Class。

但这个定义太不行了，后来人们有了更严谨的定义。

这东西真难，所以从简单的开始。



##### Polynomial-Time Reduction

考虑这样一个事：什么情况下如果问题 $S$ 能 poly 解决那么问题 $T$ 能 poly 解决（在不知道 $s$ 能不能解决的情况下）。那么有如下定义：

定义 $Y\leq_p X$，当且仅当如果有一个能 poly 解决 $X$ 的程序，那么 $Y$ 可以在 poly 次常规运算加上 poly 次调用 $X$ 下解决。（这个记号表示 $X$ 不比 $Y$ 简单）

这里调用 $X$ 的大小应当是 poly 的，但这可能也不影响：可以认为准备状态算常规运算。因此似乎也可以不管调用 $X$ 的次数。（抓细节可以搞出一车，这里算了）



显然的推论：如果 $Y\leq_p X$，那么 $X$ 能 poly -> $Y$ 能 poly（直接带入），同时 $Y$ 不能 poly -> $X$ 不能poly

然后开始一些规约小热身：

###### IS / VC

Independent Set: 给一个 $n$ 个点的图，问最大独立集是否 $\geq k$（众所周知我们一般考虑判定性问题）

Vertex Cover: 给一个 $n$ 个点的图，问最小点覆盖是否 $\leq k$

IS $<=>_p$ VC : 显然独立集取反就是点覆盖，那么第一个 $\geq k$ 当且仅当第二个 $\leq n-k$。

###### VC / SC

Set Cover: 给定元素集合 $S$ 和 $n$ 个 $S$ 的子集，问是否能选出 $k$ 个集合并起来是全集。

VC $\leq_p$ SC：按定义就是相邻边集覆盖点集，那么 VC 可以自然转化为 SC。

Set Packing: 给定元素集合 $S$ 和 $n$ 个 $S$ 的子集，问能否选出 $k$ 个两两不交的集合。

IS $\leq_p$ SP：还是拿出相邻边集。

###### 3SAT / IS

一个经典的往 IS 的规约思路（gadgets）：考虑将每个点换成一个小结构，满足亿些性质。但是构造真难。

3SAT: 给 $n$ 个变量 $m$ 个 Clause, 每个 clause 给三个单变量表达式（a 或者 a 取反）的 or，求能否满足所有 clause.

3SAT $\leq_p$ IS：考虑每个 clause 建 $3$ 个点，分别表示是否要求这个表达式被满足。然后往 IS 转化：每个 clause 的点两两连边，这样大小为 $m$ 的独立集中每个 clause 必须正好选一个。然后将冲突的限制两两连边表示不能同时选，这样就变成是否存在大小为 $m$ 的 IS，然后显然没有更大的。

构造可以很深刻，比如 Hamiltonian Cycle -> IS



规约还有显然的传递性：$X\leq_p Y,Y\leq_p Z$ 那么 $X\leq_p Z$，证明直接。那么我们可以将这些东西全部串起来。

##### Formal Definition of NP

在很早的时候，人们确实通过一些精妙的构造拿问题来回规约。事实上这样规约现在在别的地方仍然在用，但对于这一类问题人们有了更高明的东西：



众所周知，我们称一个问题是属于 P 的，当且仅当它能被 poly 求解。

定义一个问题是属于 NP 的，当且仅当它（的解/证明）能被 poly 验证。具体来说，问题 $f$ 属于 NP 当且仅当存在 poly 的算法 $V$，满足：

1. 如果 $f(s)$ 为真，则存在 poly 大小的输入 $t$，使得 $V(s,t)$ 为真。
2. 如果 $f(s)$ 为假，则不存在这样的 $t$。

也可以把 $t$ 看成随机输入，然后就变成了非确定性图灵机（所以叫NP），但细节不太算法。



显然上面的那堆问题是 NP 的：都是问是否有一组解，验证解是简单的。



显然 $P\subset NP$：拿一个不管 $t$ 直接算的 $V$ 即可。

别的问题都是极其极其难的，别想了。

##### NP-Completeness

因为人们几十年都不会做 Complexity Class 的相等性，因此搞出了 Complete 这东西：如果 Class 内的所有问题都能规约到它，则它是 Complete 的。

这里的规约比较神必，但对于 NP 来说，规约就是 poly 规约。这样就定义了 NP-Complete。

显然 P=NP 当且仅当有一个 NPC 能 poly 做，但是有生之年别想了。



但更重要的事情是：定义一个东西很简单，但定义一个不存在的东西毫无意义。因此首先有一个问题：是否存在 NP-Complete 的问题？这个问题看起来很难满足，但答案是肯定的。



###### Circuit Satisfiability

现在考虑一个逻辑电路：一个逻辑电路由 $n$ 个节点组成，节点有如下类型：

1. 输入节点，没有其它输入，它的值可能是定值 $0/1$，也可能是输入变量 $x_i$。
2. 中间运算节点，其指定两个节点作为输入，同时指定一种逻辑运算。其值为两个输入的值运算后的结果。输入关心不应构成环。
3. 有一个节点作为输出节点。

对于 poly 层面来说，中间节点指定两个还是多个完全不影响，因为分治一下 log 层就可以做多个。



那么这个问题是：给一个 $n$ 个节点的逻辑电路，求是否有一组输入使得电路输出 $1$。

首先显然这个问题是 NP 的：验证解只需要模拟电路。



但还有最关键的结果：可以发现任何一个 poly 的验证器都能被写成 poly 大小的电路，那么任何一个 NP 问题的验证器都可以变成问是否有一个输入使得验证器的电路输出 $1$。那么它就 NP-C 了。

为什么能写成电路？首先图灵机是简单的：对于固定的 $n$，找出需要的步数上界（那么只会 touch 这么多纸带），然后大力记录当前位置左侧的这么多纸带和右侧的这么多纸带，显然移动和更新值都不难处理（也就多了亿个 $n$）。然后经典结论说图灵机和 word-RAM model 在 poly 规约下等价，但我不会。



那现在我们就真的有了一个 NPC 的问题！!1 



但这个问题太神必了，还有没有更多呢？因为 $\leq _p$ 有传递性（上一部分证了），那么如果 $S\leq_p T$ 且 $S$ 是 NPC，那 $T$ 就是 NPC，证明直接。因此考虑能不能让它 $\leq_p$ 别的形式更简单的问题。进一步，如果我们有了更多的 NPC 问题，那么只需要一个问题 $\leq_p$ 当前问题，那么当前问题就是 NPC 的。



然后就可以开始真正的规约小练习了：

这里需要注意：规约是把已知 NPC 的问题规约到当前问题，而不是反过来。

同时，规约不一定是线性的（可以是 $n^k$），也不一定只需要一次（虽然不一定 ）

###### 3-SAT, IS, VC and SP

Theorem. 3-SAT 是 NPC 的。

Proof. 对于一个电路，考虑将它的每个取值表示为一个变量，那么输入输出的限制显然是单变量 clause。然后考虑逻辑门 $(a,b)\to c$。暴力地想，一个 $(a,b,c)$ 的 clause 可以去掉一种 $(a,b,c)$ 的取值，那么实在不行所有情况全塞进去即可。因此 CS 可以 poly 转化为 3SAT，那么 3SAT 就 NPC 了。



那么再根据之前的结论，3SAT $\leq_p$ IS $=_p$ VC $\leq_p$ SC，那么它们都是 NPC。于是我们有了很多 NPC 问题！!1

###### Hamiltonian Cycle

DHC: 给一个 $n$ 个点的**有向**图，问是否存在一个经过所有点的简单环。

考虑将某个问题转化到 Hamiltonian Cycle。考虑哪个问题好做，~~但看起来都不好搞~~。



根据一些指导，3-SAT 出发会容易一些：它的结构比别的更基础（本质）

3SAT-> DHC:

考虑怎么用 DHC 表示 3-SAT，可以发现一个很好的结果：定向可以表示 01 变量。那么考虑 $n$ 对点，每一对点间连双向边，规定一个方向表示 $0/1$，另一个方向反过来。然后考虑 3-SAT 的 clause: 三个表达式中至少有一个为真，相当于三种定向中至少有一个为真。

那么考虑如下构造：对每个 clause 造一个点，让这三种定向能“走到”这个点，这就限制了至少需要一种这样的定向成立。那么考虑在本来的定向 $s\to t$ 上加入 $s\to x_i\to t$ 的额外边，这样只有 $s\to t$ 时能经过 $x_i$，连三组边即可——但这真的对吗？可以发现还有一车细节问题：如何保证不通过 $x_i$ 跑到别的位置去。

那考虑每对点中间加一车点，但直接搞还需要解决走了一半跳出去，之后通过别的 clause 跳回来的方式。可以发现只需要让每个 clause 跳到的位置不同，就能避免这样的问题！!1

具体来说，每个变量考虑 $2m+2$ 个点：$s_i,v_{i,1},v_{i,2},\cdots,v_{i,2m},t_i$ 连成双向链。对于每一个 clause，新建一个点 $x_i$，然后对于每个子变量对应的定向 $s_a\to t_a$，连边 $v_{a,2i-1}\to x_i\to v_{a,2i}$，或者反过来的定向。最后需要把这些边拼起来，因此考虑 $s_i,t_i$ 连向 $s_{i+1},t_{i+1}$，然后连成一圈。

考虑此时的一个环，显然的合法方式是按顺序经过每条链，中间可能跳到 $x_i$ 上再跳回来。如果通过 $x$ 往其它链跳，可以发现 $v_{a,2i}$ 或者另一个点就剩下来了，且没有别的 $v_{a,2i}$ 连到它，那么这种情况一定不合法。因此只能顺序跳，这样就正确地描述了一个 3-SAT。做完了.jpg



然后考虑无向的 HC。显然的想法是从 DHC 推过来。那么有一个简单一些的构造：考虑直接把每个点拆成 in-u-out，然后连边从 in,out 连。这样一个无向哈密顿回路必定经过 $u$，那么必定经过 in-u-out。然后将所有 in-u-out 接起来就是有向的。



还有如下问题：

Traveling Salesman Problem: 给一个带权有向完全图，求最小权哈密顿回路。

显然把边权设为 $01$，然后看答案是不是 $0$ 就对应只考虑 $0$ 边的回路。那么 DHC $\leq_p$ TSP。根据刚才的结论无向也对。



###### Hamiltonian Path

(D)HP：问是否存在一条经过所有点的链。

HC -> HP: 考虑破环为链，选一个点 $s$ 作为开头，那么需要在一个能到 $s$ 的点结尾。因此考虑将所有连向 $s$ 的边转向 $s'$，这样满足 HC 当且仅当存在一条 $s\to s'$ 的哈密顿链，且显然是 iff 的。



###### 3D Matching

给定 $n$，有若干三元组 $(x,y,z)$，所有数在 $[1,n]$ 之间，求能否选出 $n$ 个数使得每个位置上每种数出现正好一次。

显然这个问题是 2D 的扩展。 2D 显然是 P 的，但可以发现 3D 是 NPC 的：

我的构造：

考虑从 DHC 推过来。可以发现 DHC 相当于如下限制：

选择 $n$ 条有顺序的边，满足如下性质：

每个点入度出度为 $1$，且第 $i$ 条边的终点是第 $i+1$ 条边的起点。

最后一个条件是为了保证不出现很多环的情况。（不加这个条件问题显然是 P 的），因此需要顺序。

那么考虑 $n^2$ 个点，前两组用 $(i,j)$ 表示第 $i$ 个点是否是第 $j$ 条边的起点/终点，第三组拿来凑数。对于每条边和每个 $j$，放一组 $((s,j),(t,j+1),j)$。然后每个点需要有一个终点和下一个起点，因此每个点放很多组 $((i,j),(i,j-1),new)$。可以发现一个点合法当且仅当它用了后面这些中的 $n-1$ 组，然后剩下的连成环。因此对于每个点新建 $n-1$ 个 $new$，然后两两配对，这样必须留下一组给之前的匹配。然后根据之前的结论能将留下的 $(i,j)$ 配对好当且仅当存在有向哈密顿回路。然后就做完了。

书上的构造：

还是考虑 3-SAT。考虑描述一个变量。但这里的问题是一个值可能用多次。可以发现(?)如下构造：

考虑一个偶环 $v_1-v_2-\cdots v_{2l}$。然后再来 $2l$ 个点 $s_i$，然后放匹配 $(s_i,v_i,v_{i+1})$（这里最后两个点需要交错放）。那么可以发现只有两种匹配方式，一种留下所有 $s_{2i}$，另一种留下所有 $s_{2i+1}$。这就能表示 $01$ 了。

然后考虑每个 clause，需要若干个中至少有一个是满足的，那么考虑每个 clause 两个点 $x_i,y_i$，然后从每一组需要的 $s$ 连一组 $(s,x_i,y_i)$，这样合法当且仅当有一个变量满足取值，然后拿出一组即可。最后显然会多留下一车 $s$，那么考虑再建一堆 $(s,new_1,new_2)$ 把点数平衡即可。



bonus: 3 Matroids

显然 3D Matching 是三个 uniform matroid 的交，这直接说明三拟阵交是 NPC 的。（也可以用哈密顿路的双uniform+graph）



###### Graph Coloring

GC: 给一个 $n$ 个点无向图，求它是否能被 $k$ 染色。

这又是一个和 $2,3$ 有关的问题：$2$ 染色是众所周知的线性问题，但 $3$ 染色很难。

考虑规约。但别的问题看起来都不像染色：选点之类的看起来很难转化过来，哈密顿回路也不太行。

那还是考虑万能的 3-SAT。考虑一个三元环，这样就有了明确的 $0,1,2$。然后考虑每个变量的取值，连三元环 $(a,b,2)$，这样 $(a,b)$ 一定是 $(0,1)$ 或者 $(1,0)$，它就描述了一个变量的取值。

然后考虑一个 clause 怎么做。考虑单个变量（或者取反），我们希望构造一些东西使得它取 $1$ 时是好的，取 $0$ 时是不好的。可以发现单变量是简单的：直接连到 $0$ 即可。但剩下的就不那么简单了。考虑加一个点，和它以及固定 $1$ 连边。这样如果是 $1$ 则当前点可行取值为 $0,2$，否则只有 $2$。那么两个变量就能做了：将两个新加入的点连起来，只要有一个 $0$ 就合法。再考虑三个变量，考虑刚才加的点再连一个点，这样如果初始是 $1$ 当前就可以取所有值，否则不能取 $2$。那么三个点连三元环就行了。



然后考虑 $>3$ 染色，这看起来就比 $3$ 染色难：考虑加一个连向所有点的点，那么色数直接 $+1$。加 $k-3$ 个即可。



###### Numerical Problem : Subset Sum and Others

还有一些问题的复杂度与值域有关。例如众所周知的背包问题，复杂度 $O(nW)$。它看起来是多项式的，但有一个问题：输入数只需要 $O(\log W)$ 位，因此“问题规模”实际上是 $n+\log W$。因此这样的算法实际上不是 poly 的。另一些例子例如分解质因数。

我们称这样的算法为伪多项式算法，即复杂度包含 poly W。但它不属于我们认为的 P。一个好消息是正常的运算复杂度是 log W 的，所以在 poly 范围内不需要考虑运算复杂度的影响。然后是问题：



Subset Sum: 给一堆数，求是否存在一个子集和为 $k$。这里值域是 $\exp(n)$

直接的规约：考虑 3D Matching，将每个集合写成 $s^xs^{n+y}s^{2n+z}$，然后让 $s=998244353n$。这样显然不可能进位，存在完美匹配当且仅当存在和为 $s+s^2+\cdots+s^{3n}$。

或者拿 IS,VC 啥的也能证：拿一些数把空位补上即可。



小练习：有一堆任务，每个任务有开始时间 $s$，结束时间 $t$，用时 $x$。你需要用时间段内**连续**的 $x$ 个时间完成该任务，不能切换。

拿 SS 规约，考虑一堆限制 $[0,S]$ 的问题，让它们用时加起来是 $S-1$。然后来一个 $[x,x+1]$ 的问题，合法当且仅当能正好在 $x$ 停下来，那么就是一个 subset sum。



注意这里都需要 W 很大，如果 W 是 poly n 的那伪多项式做法就真的 poly 了。



##### Intro to co-NP

定义一个判定问题的补(Complementary)表示将输出取反。

P 问题的补显然还是 P 的，因为直接拿算法跑出确定结果就对了。

但 NP 的补就不简单了：NP 的定义是如果 yes 那么存在验证方式，否则不存在验证方式。但反过来 $\exists$ 和 $\forall$ 就完全不一样了。

NP 和 co-NP 的关系属于一车 Complexity Class 未解之谜中的一个。事实上因为 P=co-P，那么显然 P=NP=>NP=co-NP。



还有更多的问题：例如有一个 Class 是 $NP\cap co-NP$。显然 $P\subset$ 它，但 $P$ 是否等于它？这（显然）是另一个 Open Problem。

(From wikipedia) 很好的例子是整数分解：判定 $n$ 是否有 $\leq k$ 的非平凡因子。NP 是显然的：给一个因子即可。它还是 co-NP 的：考虑给出真正的分解，众所周知(?)素数判定可以确定性 poly。但这个问题人们并不会 P。



##### Summary

Packing Problem: IS, SP

Covering Problem: VC, SC

Partitioning Problem: 3DM, GC

Sequencing Problem: HC, TSP

Numerical Problem: SS

~~Fundamental~~ Problem: CS, 3SAT



##### Exercises

方向别规约反！!1

几乎所有题都是造方案，那么显然 NP，这里只写 Completeness 规约（其实是忘了）

1. 这东西是 P 的，所以虽然看起来不好规约答案还是 Y/N
2. 显然完全等价于 SP
3. 完全等价于 SC
4. 等价 SP/ P(直接枚举) / P(二分图匹配) / 等价 IS(显然是个图)
5. 考虑每个元素覆盖的集合，然后是 SC，显然双向
6. 只用双变量就是 VC
7. 让两维相同
8. 每种就用一次，可以解决 3DM，也可以从 SS 跑到集合划分
9. SP，拉个完全图，按照集合内部大小排序造路径。
10. a: SC，和上一问一样。b. 大力删点
11. 拿 3SAT 规约，每个变量给两条链，走哪条表示选哪个值。将链接起来就相当于每个变量取一个值，然后每个 clause 直接写上去。
12. 拿 SP，建 $n$ 层，再加 $n-k$ 个额外标签，每层可以用一个额外标签或者用一个 set。
13. 就考虑 $1$，然后就是 SP。
14. SP，实在不行暴力加
15. SC，同上
16. 拿 3-SAT，每个变量两个值然后要求 $\cap=1$，每个 clause 把三个变量放进来，然后放两个额外元素，然后要求 $\cap=3$
17. HP，加源点汇点，然后中间边权全部设为 $1$，汇点往源点连一条 $-(n+1)$，这样必须经过这条边。
18. 全部 yes 或者弃权就是 SC。
19. 1是网络流，2 $k=1$ 平凡，$k=2$ 是二分图+polyW背包，否则把容量扔掉就是图染色
20. $>B$ 连边就是图染色，然后这题边权任意
21. IS, 来 $k$ 层，每层塞所有点，然后两两层之间连上所有关系。
22. 加一个点连向所有点。
23. 经典OI题：当前匹配状态一定是剩余某个 $a_i$ 的后缀或者 $b_i$ 的后缀，枚举加哪个串建图，那么状态数 poly，所以有解一定 poly。
24. $b=n$ 就是 SC。
25. 分段，每一段 $01$，然后 $b=n$ 就是 SC。
26. 加一对 $B-k,B-(s-k)$，其中 $B=19260817(nW)^{10}$，那显然这两要分开，然后就是 SS。
27. $k=2$ 然后 $\frac 12(\sum v)^2$，那就是上一问。
28. SC，点在一边集合在另一边，中间对应连边。然后将点那一侧全部连起来这样就不能选点了（否则答案是 $1$）
29. 发现啥都不行，考虑万能的 3SAT：每个变量两个点 $x_0,x_1$，它们连向一个点，这样这三个点中至少需要选一个点。然后每个 clause 向对应三个 $x$ 连边，表示至少需要一个去覆盖。那么 3SAT 有解当且仅当存在 $n$ 的 dominating set.
30. 考虑拿 IS 过来，每个点放一个 $-x_i$，每条边放一个 $W x_ix_j$。显然答案不超过 $0$。考虑让 $W=n^{10}$，这样答案为负时不会有两个相邻点点权超过 $n^{-2}$，那么最小值不小于 $-$ 独立集大小加上 $\frac 1n$，让 $B=-k+\frac12$ 即可。
31. 考虑 VC，在图上每条边上加 $2n$ 个 $s-x-t$，那么不可能删光 $x$，且删掉 $s,t$ 中任意一个后这些 $x$ 就变成了毫无影响的叶子，那么 FS 就相当于删掉尽量少的点使得不存在边，这就是 VC。
32. 考虑每个 $s$ 的前后部分分别两两不同，这样一个 $t_i$ 只贡献一对 $s_1\to s_2$，所以是有向哈密顿链。
33. 两个人（显然多个人不影响 exp），一个人只有一个物品 $(x,y)$，那就是另一边能否拿出重量和 $\leq x$ 的物品使得价值 $\geq y$，所以是背包。也可以就来一个 $(x,x-2)$ 然后价值重量相同，然后直接 SS。
34. 考虑两层的图，第一层 $\theta=1$，第二层 $\theta=\epsilon$。第一层表示集合，连向第二层的元素。问 $(k,k+n)$ 就相当于是否存在 $k$ 的 SC（每选一个点只能加一个第一层的元素）
35. 简化一手问题。考虑只在最后一个点卖，然后来两种资源。前面放若干层，每层两个点分别卖两种资源，这样相当于每层选一个问能否两种资源都超过上界，那显然是大权值背包，也容易变回 SS。
36. 考虑每种材料给两个 special，其中有一个是first，然后 $i=t=2$。这样能减一当且仅当 $b$ 在 $a$ 的下一个，那么哈密顿链很容易搞过来。
37. 同 35，还是分层，每层两个点，然后就是背包。
38. 考虑两部分，第一部分是完全图，第二部分是给定点，内部没有边。然后每个左侧点向右侧一部分点连边，可以发现就是选出尽量少的左侧点将右侧所有点覆盖，那么是 SC。
39. 有点困难，那回去考虑 3SAT。考虑每个变量给两列点，然后 $s_i$ 到这两列到 $t_i$，这样每条路径会走一列点留下另一列，这就相当于变量取值。然后考虑 clause，拿 $s_i$ 向三个对应取值列的第 $i$ 个连，再连到 $t_i$。这样需要至少一列没有在上一步被用。显然不可能走到别的地方去。这里取两列是为了避免不同 clause 的冲突。
40. $s_i=n+1$，不准切换问能不能 $n-1$ 秒就是给定 $s$ 的哈密顿链。HP 加一个超级源点就对了。
41. 1是入度到出度的匹配(CodeChef PARADES)，2可以发现 3SAT->3DM 的匹配拿过来正好对了（按照构造顺序考虑可以发现没有别的三元环）。
42. 拿 41 过来，显然 41 的构造没有二元环，那就是问能不能 $k=\frac n3$。



#### Day 4-5(9/21-9/22)

Chapter IX - Intro to PSPACE

##### PSPACE

NP-Complete 绝不是复杂度的结束：似乎还有一些问题比 NP 更难，至少人们不会在 NP 内解决这样的问题。

事实上 NP 往上还有一大堆 P 相关复杂度，但这里我们考虑一个相对最正常的：

Def. 我们称一个问题是 PSPACE 的，当且仅当它存在（确定性）多项式**空间**复杂度算法。

显然的结论：

1. $P\subset PSPACE$

证明：显然。

2. $NP\subset PSPACE$

证明：直接搜 NP 的验证算法的所有输入然后暴力验证，显然搜的部分和验证的部分各自使用 poly 空间。

3. $co-NP\subset PSPACE$

证明：类似上一个

但它们进一步的关系仍然属于 open 的一万个问题之一，甚至 P,PSPACE 是否相等都是未知的，这太难了。



考虑一些 PSPACE 中的问题。虽然显然 NP, co-NP 啥的都在里面，但更有意义的显然是人们还不会，甚至有希望 Complete 的：

###### Quantification SAT

QSAT: 本来有一个 $n$ 个变量的逻辑命题 $f$，众所周知找一个解是 NP-C 的，但现在考虑如下命题：
$$
\exists x_1,\forall x_2,\exists x_3,\cdots,f(x_1,\cdots,x_n)?
$$
即往找一个解的问题上加一堆 $\forall$ 然后交替着来，然后这个问题就变难了：显然 $\forall$ 没法快速验证。

容易发现它是 PSPACE 的：考虑爆搜验证命题，那么每个子问题形如：确定了一段前缀后，后面的命题是否有解。考虑直接递归，时间复杂度指数，但可以发现空间复杂度很小：只会递归 $n$ 层，每层空间 $O(n)$，那么空间 $O(n^2)$。

这个地方可以发现递归层数很影响问题，后面有更深刻的例子。



###### Games

一个和 QSAT 很相似的例子是二人博弈：求先手是否存在必胜策略，就相当于是是否存在先手第一步操作，使得后手第二步无论怎么操作，后面先手都能必胜（然后又是 $\exists,\forall,\exists,\cdots$）

但如果游戏可以无限进行就炸了。因此可以发现：所有步数有 poly 上界的二人博弈都是 PSPACE 的。

一个例子是如下游戏(CFL)：一张有点权的图，双方轮流选点，要求选出的所有点构成独立集。双方希望最大/最小化第一个人选的点的点权和。



###### Planning

考虑如下（看起来比较 general）的规划问题：

有 $n$ 个变量，它们组成了一组状态。有 $m$ 个操作，每个操作为如下形式：

给定三个变量集合 $Q_i,A_i,D_i$。如果 $Q_i$ 中变量都为 $1$ 那么可以使用这种操作，操作效果是将 $A_i$ 中变量设为 $1$，将 $D_i$ 中变量设为 $0$。

给定起始状态和终止状态，问能否完成操作。



事实上显然有如下指数空间的算法：将 $2^n$ 个状态全部设出来，然后 bfs。但我们的目标是 PSPACE。这个问题比上两个更难的地方在于，操作次数没有限制。

事实上通过指数算法容易发现一个简单的结论：如果有解则操作次数不超过 $2^n$。因为整个过程相当于状态上找一条路径，那么显然没有环。但这完全不够：如果直接搜，递归深度是指数级的，那么记录这个递归就超过了空间限制。

此时有一个高明的分治：

设 $f(S,T,l)$ 表示能否在 $l$ 步内将 $S$ 变为 $T$，枚举中间状态 $(\frac l2)$ 然后向两侧递归。

可以发现这样递归层数就变为了 $\log 2^n=O(n)$，然后它就 PSPACE 了。



事实上这东西在别的地方也有用，例如矩阵行列式的 Quasi-NC 做法：转成奇怪的路径覆盖然后大力分治降并行深度。

还有一个类似(?) 的推论：

###### NPSPACE

NPSPACE 定义为非确定性图灵机能在多项式空间内解决的问题。

但与 NP 不同，这里有直接的结论：

PSPACE=NPSPACE

感性证明：考虑用每一步随机走的非确定性图灵机。那么它有一个 poly size 的状态和可能是 $2^{|states|}$ 的操作步数（显然不可能更多）。那么考虑上一个分治，每次枚举中间状态向两侧分治，那么空间复杂度不超过 $|states|^2$（深度和状态大小都是这么多），那么就确定性了。

但 NPSPACE 还是有用的：可以拿来证明一些东西 PSPACE。



##### PSPACE-Completeness

和 NP 部分一样，我们又开始考虑 Completeness 的问题：

称一个问题 $X$ 是 PSPACE-Complete 的，当且仅当 $\forall Y\in$ PSPACE，$Y\leq_p X$。

实际上这里的 $\leq_p$ 似乎有些严格，因为其实可以调用 exp 次，只要大小合适。但可以发现在严格定义下也是有结果的：



###### QSAT

QSAT is PSPACE-Complete.

证明直接超出了本书范围。这里的难度主要在于 PSPACE 的算法太难描述了。好消息是 $\exists,\forall$ 和 SAT 的 $\to$ 够描述逻辑了。



###### Competitive 3-SAT

考虑一个 SAT，双方按照某种两人操作顺序赋值，最后合法则先手胜。

显然这个和 QSAT 完全等价。



###### CFL

Recall definition: 两人轮流选点，要求构成独立集。先手获胜当且仅当他选的点权和 $\geq$ 某个数。

考虑用它描述 C3SAT。首先考虑变量取值，考虑每个变量来两个点 $x_{i,0},x_{i,1}$ 相互连边，表示变量取值。显然每一组最多选一个。

然后考虑描述取值顺序。首先考虑轮流操作的情况，此时可以让每对点取 $c^{2n(n-i)}$，这样一定先顺序取过去，然后就是轮流取值。为了避免神必策略可以让 $b$ 强制等于 $1,3,5,7,\cdots$ 位置之和

对应不轮流操作的情况，考虑插入一些 $c^{2n(n-i)-j}$ 单点，这样（在正确的 $b$ 下）双方一定先去选对应的值。

然后考虑 clause。考虑建一个三元环分别连向三个对应变量的补，这样三元环能选一个当且仅当三个对应变量有一个正确。那么这部分相当于能赢当且仅当先手接下来能每个三元环选一个。但这样需要先手连着操作，那么类似之前的方式搞一下即可。



证明 QSAT？在路上了



##### Exercises

1. 首先显然双方会选 $1,0,1,0,\cdots$。（选另一个更差）然后发现顺序固定，那就只需要判定一种情况是否合法。
2. 非常难问题，所以留到下面拉单独一段来写
3. 大家都会的 dp。

Solution of ex2:

考虑拿什么问题规约过来。Planning看起来太难了，CFL 有权值和这里不大配合，那还是只能 QSAT 或者等价的 C3SAT。

但这个问题是个路径博弈，需要考虑怎么把 SAT 博弈转化过来。上一章的一个例题是 3SAT 规约哈密顿回路，但哈密顿回路和这个差距有亿点大。可以发现更好的例子是 ex39：每个变量两列点，钦定只能走一列，另一列就表示取值；每个 clause 建两个点 $s_i,t_i$，$s_i$ 向三个点连边再连向 $t_i$，合法当且仅当能走一步过去。

考虑能不能转化为博弈。一个直接的想法是先把 $n$ 列点串在一起，这样走过去就相当于双方博弈取值；然后再验证的 clause。但此时有一个关键的问题：如何保证两部分（取值/验证 clause）的边不互相影响？

首先考虑第二部分。第一个问题是如何验证。直接的想法是把所有 $s_i,t_i$ 顺序接起来，然后顺序验证。但这样对奇偶性的要求有亿点大：验证顺序可以很快搞过去，但等会第一部分的分析死活搞不过去。注意到有一个不合法 clause 就炸了，可以发现一个更好的方式：后手选一个 clause 走到 $s_i$，先手选一个满足条件的点验证，验证成功则先手胜。这样就不需要 $t_i$ 了！!1

但问题是这里后手可以通过之前没走完的这一列继续往后走到底。考虑解决这种情况。首先一个直接的想法是变量对应的两列点开头结尾放两个点把两列点合并起来，这样就不会走到下一列点去，同时对第一部分也有很好的效果（先后手）。那么第一部分完成后右侧聚合的点被走过了，向右不会超过这个点。那么只需要保证每个 $s\to$ 的点在这一列上到聚合点中间有偶数个点，后手向右走就是后手输。

然后是第一部分。根据之前的分析，每个变量会出现两列点，两个变量之间有一些单点作为分隔。我们希望能顺序走过去。两人先后手的问题可以通过调整中间单点的数量解决。然后因为第二部分没有从列上连出点，所以可以发现毫无影响。这里删掉 $t_i$ 太关键了。所以只需要在第一部分结束的地方加单点到下一步后手，然后连向所有 $s_i$，这样就完成了 QSAT，因此它是 PSPACE-hard 的。$\in PSPACE$ 是显然的：直接搜就对了。

事实上这个图删掉最后的一条边就是个 DAG。DAG 问题大家都会线性，但有趣的是加一条边它就 PSPACE-complete 了。



最后的一些话：

关于 PSPACE，之前说了步数 poly 的二人博弈是 PSPACE 的，事实上很多这样的博弈是 PSPACE-complete 的，例子其实很多但每个构造都很难。

fun fact：很多 AI 做的问题都是 PSPACE-complete 的，例如上面三个。

PSPACE 还不是结束。再往上还有 EXPTIME————指数时间。显然 PSPACE <= EXPTIME：poly空间只有exp个状态。然后还有 NEXPTIME。接下来是类似的 EXPSPACE，然后同样地有 EXPSPACE=NEXPSPACE。这些 class 中都有 complete 的问题。相等的问题还是很难，但人们知道 Time/Space Hierarchy Theorem。我完全不会所以咕了。再往上还可以有 2-EXP，一直下去还有 ELEMENTARY，但我完全不懂。

P,NP,PSPACE 这些研究的很多的问题中间还有一大车 class，但这远超本书内容了，我也完全不懂。



#### Day 6-8 (9/23-9/25)

回到 NP 的世界。当我们证明一个问题是 NP-Complete 之后，找到它的通用做法就显得不那么可能（人们几十年在成千上万个问题上都没有找到）。那么算法研究还有什么有用的方向呢？接下来的部分将会全部考虑这一问题。



##### Special Cases

Chapter X : Special Cases

一种方式是，我们考虑 NP-Complete 问题的一个特殊例子。这样的例子实际上非常多，这里只举一些简单的形式。





###### Trees

在输入的图（也可以是别的东西）有更简单的结构时，问题可能有比一般情况简单得多的算法。这种 adhoc 的东西在某个三个字符的比赛中经常出现。这里考虑一个经典情况：树。

树很好的一个性质是每个子树都只和外面有一条边相邻。



树上独立集：大家都会的 dp。

类似例子太多了，OI 侧有至少几百个。



###### Other Parameters

有时问题中不只有问题规模，还有别的参数，例如 $k$。在这些参数很小的时候，有一些复杂度类似 $O(exp(k)*poly(n))$ 的算法。另一种例子是值域很小的情况，典例是 $O(nW)$ 的背包。例如如下问题：



求是否存在大小为 $k$ 的 vertex cover。其中 $k=O(\log n)$。

hint: 我们的目标复杂度是 $2^k*n$ 之类的东西

有了 hint 之后就容易了：考虑选一条还没被覆盖的边，那么两个端点必须选一个，然后继续 dfs。只会递归 $k$ 层因此复杂度 $O(n2^k)$。



另一个例子：环上线段染色使得相交线段不同，判断是否存在答案为 $k$ 的解。无比 naive 的 dp 就是 $O(exp(k\log k)*n)$ 的



##### Tree Decomposition and Tree-Width

正片开始.jpg

我愿称之为广义树形 dp.jpg



###### Definition and Properties

在第一部分我们发现(?)很多 NPC 在树上很简单，但树的局限性有点大。在第二部分我们又意识到，拉一个小的参数有的时候能得到更好的做法。

考虑能不能搞到更一般的情况。那么有一种广义的“树”：

我们定义图 $G$ 的 Tree Decomposition 是一棵树 $T$，其中 $T$ 上每个节点对应一个 $G$ 点集的子集 $s_i$，满足如下性质：

1. 每个点至少在一个集合中出现。
2. 每条边的两点至少被一个集合同时包含（这样就考虑了这条边）
3. 对应每个 $G$ 中的点，它在 $T$ 中出现的集合在 $T$ 上构成一个连通块。

前两个条件是显然的。第三个条件是为了使得这东西真的看起来是一棵树：如果把每个子集看成一个大点，那么子集间相交的关系就构成了 $T$ 的树关系，这个限制是为了避免本来不相关的子树之间产生相关性。事实上有如下结论：

删掉 $T$ 上一个点以及它对应的 $G$ 中点集，$T$ 中剩余的每个子树构成不同的连通块。

证明非常直接：从 $3$ 性质出发即可。不经过当前点的一定在一个子树内。

这可以看成树上删点，实际上我们还有树上删边：

删掉 $T$ 上一条边以及对应的 $s_x\cap s_y$，那么 $G$ 被分成两个连通块对应 $T$ 的两个连通块。

证明类似。



但我们并没有限制 $T$ 的大小，这看起来不太好。但实际上我们有：

考虑如果 $T$ 上（树上）相邻两个集合 $S_1,S_2$ 满足 $S_1\subset S_2$，那么显然可以把两个集合合并起来而不产生额外影响。那么考虑这样一直合并，这之后一定不存在两个集合满足这一性质（否则违反性质 $3$）。

此时可以发现如下性质：

最多有 $n$ 个集合。

证明：考虑 $T$ 的一个叶子，它一定独占了 $G$ 的一个点，否则它就被包含了。



（note：事实上缩完之后如果 $G$ 连通，则每个子集都必定是连通块：考虑不连通的两个点，考虑路径上每条边出现的集合，考虑这些集合在树上的情况，一定最后会全部缩起来。但这也没啥意义）



那这东西有啥用呢？可以发现它与原先树的情况有一个类似点：每个子树内与外界相邻的点之后根的 $s_i$ 中的点。因此只要这个值很小就能有类似之前的做法。

因此我们定义一个划分的 Tree-Width 是所有集合的大小最大值减一（因为一棵树也需要每个集合大小为 $2$），图的 Tree-Width 是所有划分方式的最小值。那么对于很多问题，如果图的 Tree-Width $w$ 很小，那我们就有类似树形 dp 的解决方式，例如如下问题：



求图的最大（权）独立集，保证 Tree-Width 不超过 $w$ 且给出划分。

直接魔改之前的 dp 就可以得到如下做法：

考虑 $dp_{u,S}$ 表示考虑了 $T$ 中 $u$ 的子树，当前 $s_u$ 中选择状态为 $S$ 时子树内部选择的最大权值。

实在不行转移暴力合并复杂度就是 $O(4^wn)$，或者 $O(w2^wn)$（我猜可以，懒得编了）

但要真正使用这个算法，还有一个需要解决的问题：如何求出 Tree Decomposition？



###### Construction

坏消息是，求出一个图的 Tree-Width 就是 NP-Hard 的。好消息是我们不需要求出确切的，甚至不需要关心很大的 $w$，只需要考虑能否求出一个 $w$ 很小的划分（不需要是最小）。

但我们有如下高明的算法：

对于 $w$ 和一个图，我们可以在 $O(exp(w)*nm)$ 的复杂度内得到如下结果之一：

1. 证明 $G$ 的 Tree-Width 大于 $w$。
2. 得到一个不超过 $4w$ 的划分。

这算法好难，跑路了，下次再说。



##### Exercises

1. 每次拉一个没有满足的元素出来搜，$O(c^k*poly)$
2. 显然是 $O(3^d*poly)$ 的。然后考虑从全 $0$ 和全 $1$ 分别搜一次 $d=\frac n2$。
3. 状压 dp。
4. 显然就是三角剖分自己。
5. 大力 dp，每个点三种状态（选，被覆盖，没被覆盖）。显然 ab 一样做。
6. 大力记录当前 s_i 中三个端点被啥路径用了，要求子树内还没出来且不在端点上的路径必须在子树内被完成。这里一条里面的路径用两个端点在外面再合并的情况好像不能忽略，因为 $n=4,E=\{(1,2),(2,3),(3,4),(4,1)\},S=\{\{1,2,3\},{3,4,1}\},t=\{(2,2),(1,3)\}$，此时只能 $3\to 4\to 1$，从左边考虑过来就难了。但实在不行暴力也是 $n^w$ 啥的。
7. $k(w)=w+1$，考虑让每个集合内元素颜色不同，然后从上往下填，新加入的东西贪心染色（根据定义子树外的东西不被影响）。然后实在不行大力 dp 可能是 $w^{2w}$ 的。
8. 总共只有 $n$ 个 clause，由 Hall 定理可以找到变量到 clause 的匹配，然后每个变量管一个 clause 即可。
9. 随便 dp。



#### Day 17-18 (10/4-10/5)

Chapter XI : Approximate Algorithm

另一种方式是不考虑求出确切的最优解，而是考虑求出一个近似优秀的解。这个想法的来源是十分自然的。

对于“近似”，我们通常考虑最优化问题，且指的是求出的解和最优解的差（通常是）不超过 $k$ 倍。当然也有差常数的近似（xtq orz），还有计数近似（非常恐怖），...

近似的一个问题是，我们需要和最优解比，但我们不会算最优解。这一困难在接下来的每一部分都会体现。

在这个背景下，我们来考虑一些常见的方法类别。

##### Greedy

众所周知编贪心是简单的，证明贪心最优可能就没那么简单了。这对于证明贪心的近似最优也成立。

###### Balance Packing

给 $n$ 个数，将它们分到 $k$ 个部分中，使得每个部分和的最大值最小。

显然这个问题 $k=2$ 就是 NP-C（ch8 exercise），这里考虑能不能近似做。

显然有一个 naive 做法：

将所有部分从大到小排序，每次找一个当前最小的部分加进去。

显然这不可能是最优的，直接的反例是 $3,3,2,2,2$。但我们现在的目标不是这个，而是说明它能不能近似优秀。

我们不知道最优解，一个自然的想法是找一些下界然后和下界比。那么显然有如下下界：答案不小于所有数的最大值，也不小于总和除以 $k$。两个都是显然的。基于这个下界我们就能得到结论：

贪心得到的最大值不超过最优解的 $2$ 倍。

证明：每次找到的部分和一定不超过平均值（不可能全部超过），那么得到的结果不超过平均值加上一个数。



但我们还能更优：

贪心得到的最大值不超过最优解的 $\frac 32$ 倍。

证明：如果有第 $k+1$ 个数，那么答案不小于这个数的两倍。因此最后加的数不大于最优解的一半。

$3,3,2,2,2$ 说明下界是 $\frac 76$，然后我一时不会了。

###### Distance Cover

我们考虑一些广义的距离：只需要满足 $d_{i,i}=0$，对称且三角形不等式。然后考虑如下问题：

给定 $n$ 个点，选 $d$ 个点，最小化每个点到选中点距离的最小值。

问题仍然出现在我们不知道最优解上。如果知道最优解 $r$，我们有一个显然的 naive 做法：

随便看一个还没被覆盖的点，它在最优解中被一个 $r$ 的圆覆盖，那么从它开始拉一个 $2r$ 的圆就能覆盖最优解中覆盖的那些点。

那么如果知道 $r$ 可以，这样一定能搞出一个 $2r$ 的解。

然后回到原问题。一种暴力方式是二分 $r$。这样我们就得到了一个 $2$ 倍近似。还有一个高明的方式：

注意到我们的操作是每次任意选一个距离已选点超过 $2r$ 的，如果 $k$ 步后还有就不合法。在不知道 $r$ 的情况下，我们可以每次选距离已选点距离最大的，这样就完美地规避了这一问题。

###### Weighted Set Cover

Weighted Set Cover：考虑集合覆盖，现在每个集合有权值，最小化选出的权值和。

考虑怎么贪心。可以 naive 地想到：

考虑每次选择 权值 除以 这个集合能覆盖的还没被覆盖的元素个数 最大的。

但这东西的分析看起来很困难:最优解很难像上一个问题一样bound住，同时这个算法看起来也不大靠谱。

事实上我们可以让这个算法跑得非常差：考虑两列点，两个权值为 $1+\epsilon$ 的集合覆盖两列。然后考虑一堆权值为 $1$ 的集合，一个覆盖一半，下一个覆盖剩下的一半，以此类推。这样贪心会去选后面的（选一半更优，再往后情况类似），但答案是 $2(1+\epsilon)$。因此甚至它会做到 $O(\log n)$ 倍。

因为倍数很大，可以考虑一些大力的分析。但这还是不太好想（根本想不到）：

考虑给每个位置一个权值，权值定义为贪心操作中的 权值 除以 这个集合能覆盖的还没被覆盖的元素个数。然后我们有如下结论：

如果在还剩 $k$ 个点时加一个集合，那么加入点的权值不超过最优解的 $k^{-1}$ 倍。

证明：把最优解的集合拉进来，它们每一个单独拿进来时加起来能覆盖至少 $k$ 个点，权值和不超过最优解总和，那么拿最小的就满足 $k^{-1}$。

考虑取的顺序，把第 $i$ 个点加进来时前面至少还剩 $n-i+1$ 个点，所以总和不超过 $\sum \frac 1i$。

这个 “代价” 可以引出如下问题：

##### Pricing Methods / Primal Dual

我们考虑一些比较通用的分析方式。

这东西 OI 里面也有用，但描述这一方法真的很难。一种不知道对不对的描述：

我们还是考虑造下界。考虑引入一些新的权值（像对偶那样），通过新的权值有理有据地构造一些下界。例如线性规划的对偶就可以看成我们用限制去线性组合目标，得到目标的上界。另一个例子是 arc130f，我们拉一个不超过原序列且上凸的整数序列，然后容易证明答案不小于这个。在 OI 情况中，我们一般期望证明这样“对偶”得到的下界正好等于最优解，但在问题没那么好的时候这一期望通常不成立。尽管如此，我们仍然可以使用这一下界和权值来近似最优解。

###### Weighted Vertex Cover

Weighted Vertex Cover: 有权值的点覆盖。

显然可以拿上一个做，但是 $\ln n$ 太差了。

如果没有权值我们会直接每次拿一条边把两侧有选了做到 $2$ 倍，可惜这里带权。

考虑拉一个权值下界。一个想法是说每条边都需要被覆盖，那么考虑给每条边一个权值。这样可以得到如下结果（好难想）：

考虑给每条边一个非负权值 $v_e$，满足对于任意点，它的权值不小于所有相邻边权的和。那么对于任意一组权值方案，我们都可以证明最优解不小于边权之和。

证明：每选一个点都可以用这些代价填相邻边权，因为是覆盖所以每条边都会被填一次。

需要注意的是，这里的对偶并不是完全的，即这个最大值不等于最优解。例如一个三元环，边权的答案是 $\frac 32$，但显然最优解是 $2$。

但我们仍然能拿它解决一些东西：

首先我们考虑求出一个极大的边权方案：考虑每次给一条边加边权，直到不能加为止。我们称一个点是极大的，当且仅当它的权值等于相邻边权和。那么之前的操作可以看成选一条两边都不是极大的边加权值。那么操作结束时，每条边都至少有一个端点是极大的。那我们自然地可以想到：

选所有极大的点。

此时可以发现一个好处：每个点的代价正好可以平摊到边权上，每条边最多覆盖两次，那么这样求出的答案不超过边权和的 $2$ 倍。那么我们就得到了一个 $2$ 倍近似！!1

###### k-disjoint path

给一个有向图，有 $q$ 个请求：第 $i$ 个请求要求一条从 $s_i$ 到 $t_i$ 的路径。限制每条边最多被覆盖 $k$ 次，求最多能满足多少请求。

ch8 ex 告诉我们即使 $k=1$，求能否满足所有请求都是 Complete 的。因此我们开始近似：

首先我们考虑第一种贪心方法。考虑 $k=1$。显然任选一条路径很烂，尤其是在我们随手选了一条 $n$ 个点的路径的情况下。那么有一个容易发现的贪心：

每次选择一条还没被满足的 $s_i\to t_i$，选最短的一条。

设计算法很简单，关键在于如何分析。首先我们需要大概体会一下答案是啥级别。可以发现一个很不好的情况：如果我们拉一条路径，然后每条边出发拉一条稍微长一点的路径，那么最优解是选后面的所有路径，但贪心会只选到第一条路径。可以发现这样最优解可以选根号条路径，那么贪心最多是一个根号级别的近似。

考虑最优解选择的若干路径。在贪心选路径的过程中，如果某条最优解选择的路径的边被用了，就把最优解那条路径删掉。然后可以发现如下结论：

每次最多删 $\sqrt m$ 条路径。

证明：如果选的路径长度不超过 $\sqrt m$ 则显然。但如果超过 $\sqrt m$ 了，那么最优解中所有 $\leq \sqrt m$ 的路径一定全部没了（不然可以选这些），此时就剩下 $\sqrt m$ 条路径。

那么我们就是一个 $\sqrt m$ 倍近似。进一步对于任意 $k$ 类似分析可以得到一个 $k\sqrt m$ 倍。有趣的是，已经有人证出来 $k=1$ 的时候 $\sqrt m$ 级别是 $P\neq NP$ 时我们能做到的最好结果，但 $k>1$ 时下界仍然未知。

现在我们考虑加入一些权值。显然剩余次数更少的边应该更贵。

那么一个想法是，每条边每被经过一次就给它长度乘上一个 $c$。

考虑怎么分析。一个想法是类似之前的方式，按照大小分析。我们仍然考虑原先的所有最短路，记录它们在当前情况下的权值。同时如果一条最短路被用了或者某条边用了 $k$ 次，我们就把它删掉。

困难的地方在于怎么大小分类。可以发现删一条边时它的权值是 $c^{k-1}$。因此考虑(?)按照 $c^k$ 分类。那么在权值小于这个值时，贪心选的每条路径最多删掉 $c$ 条最优解的路径。

考虑更大的情况，按照惯例我们希望说明现在路径不多。之前的分析中我们用 $m$ 直接完成了分析，但现在我们显然需要带上权值。因此我们需要分析现在每条边的边权和最多是多少。显然往 $mc^{k-1}$ 放缩是不能接受的（否则就回到了根号），因此我们需要考虑更优的方法。

一个精妙的分析是，每次选出一条 $c^{k}$ 的路径然后给每条边边权乘 $c$，因此每次边权和增加值不超过 $c^{k+1}$（！）那么边权不超过 $m+t*c^{k+1}$，其中 $t$ 是之前选的边数。

那么分析一下，最优解不超过 $c*t+c^{-k}(m+t*c^{k+1})=2ct+mc^{-k}$，取 $c=m^{1/(k+1)}$ 就做到了 $O(m^{1/(k+1)})$ 倍近似。太高手了。

##### Linear Programming and ILP

线性规划大家都会：标准形式是给一堆线性的 $\sum a_ix_i\leq c$ 限制，要求最大化一个 $\sum c_ix_i$。或者将 $\leq,\geq$ 换过来。一种简洁的写法是用矩阵：限制 $Ax\leq b$，最大化 $c^Tx$。这里 $\leq$ 是对位小于等于。

可以说线性规划的对偶启发人们得到了上一种方法，但这里我们不考虑对偶。

众所周知线性规划有不依赖权值的强多项式做法，但与之同时它们几乎跑不过单纯形。

但这里我们不考虑这些，我们考虑怎么拿 LP 来做近似。首先需要注意的是，我们通常不能把问题直接写成 LP，而是写成如下形式：

Integer LP：额外要求变量都是整数。

原因是显然的。但 ILP 很难做：ILP 显然可以表示一堆 NPC 问题，例如：

考虑 VC，那么限制可以写成每个点一个 $\{0,1\}$ 权值，要求每条边两侧权值和 $\geq 1$，最小化总权值。

所以它是 NP-H 的。我们也可以说明解中用到的答案位数不大从而得到 NP-C，但这里不用考虑这一点。

一些 naive 的尝试是直接删掉整数限制拿 LP 解。对于 OI 中见到的很多特殊情况，我们通常都会跳过一些证明（例如全幺模矩阵）然后直接相信 LP 的解是整数解，或者存在相同整数解。但一般情况显然这不是最优。

尽管如此，我们还可以拿 LP 做，然后取近似。

###### Vertex Cover Revisited

我们仍然考虑带权的版本。那么我们可以写出一个 ILP。

考虑改成 LP，但 LP 的解很可能不是合法 ILP 解。例如一个三元环的情况，LP 的答案是三个 $\frac 12$。

好消息是 ILP 到 LP 删了限制，所以 LP 的最优解不大于 ILP 的最优解，然后我们就得到了很好的 bound。

考虑拉出 LP 解，那么每条边两侧至少有一个 $\geq \frac 12$。所以我们直接 $*2$ 下取整就是合法 ILP。这样就直接得到了 $2$ 倍近似。

###### Balance Packing V2

我们回到最开始的问题，但现在我们加一个限制：第 $i$ 个集合只能处理 $S_i$ 中的数。

显然有一个 naive 的 LP：考虑每个任务分多少部分给每个集合，ILP的限制是分出去的比例之和是 $1$ 且所有数都是非负整数，然后要求每个机器的和减去一个变量 $x$ 后小于 $0$，在此基础上最小化 $L$。LP 则是把比例的限制拿掉。

但这里我们显然不能暴力取整：naive 的方式需要整体乘 $n$，但这个优化比例太拉了。考虑有没有高明的做法。

Hint:删边（！这是怎么想到的）



考虑数向集合连边，没用到的边都可以直接删。如果有一个环，那么它一定是偶环。那么我们可以交替分成两个匹配，一侧加分配量另一侧对应减分配量，直到某一条边的分配量变为 $0$。然后就可以删边了。这个过程中集合权值甚至不变。

然后剩下一棵树，考虑每次删一个叶子，尽量往下匹配。这样每个集合的权值不超过之前权值加上一个数。根据之前结论后者也不超过答案，那么最后每个集合的权值不超过 $2$ 倍最优解。极其高明。



还有些更高明的 rounding：比如把 $01$ 问题拉到高维球面上做，然后找个hyperplane分割回 $01$。典例就是那个 max 2-cut 拉到 UGC 的高维投影。

##### Approximation on Value

如果解的优秀程度只和权值有关，且这个权值小的时候我们有优秀做法，那我们有非常 naive 的方式：给权值取整做个近似。

但注意如果有个权值的限制，那我们显然不能对限制做近似。

考虑经典背包问题：每个物品有重量和权值，给一个重量上限求最大权值。

这里我们显然不能对重量近似，否则就寄了。那么考虑对权值近似。

首先我们需要会权值的背包做法，那我们显然可以反过来 dp：设 $f_{n,v}$ 表示考虑前 $n$ 个物品权值和为 $v$ 时的最小重量。

然后我们直接考虑一个 $b$，把权值除以 $b$ 上取整。

考虑说明它的优秀程度。我们最多把权值多看了 $nb$，且我们一定是在放大权值，因此我们的解最多比实际的最优解少 $nb$。只需要让这个值除以最优解很小就行了。

一种简单的分析是只考虑最大的物品重量（先扔掉放不进去的），那么最优解不小于它的权值。让 $b=\epsilon/n \max v$，那么我们就最多比最优解少 $\epsilon$。复杂度为 $O(n^3\epsilon^{-1})$。因此我们可以做到任意常数复杂度的逼近。但如果我们想逼近到最优解，这样需要的 $\epsilon^{-1}$ 就是指数级的了。



##### Exercises

xtq orz

1. 反例可以直接 $k=3$ 然后 $2,2,1,1$。然后注意到相邻两个船的空位加起来不可能超过 $k$（否则贪心就放一起了），那么如果这样放了 $s$ 次，重量至少是 $\frac12 ks$，那么最优解至少需要 $\lceil \frac s2\rceil$ 次。
2. 这不就是点覆盖.jpg 不行是因为约束的东西不一样。
3. $2,B-1$。正确的近似就从大到小排个序，肯定能选到 $\frac B2$（除非总和不满）（分类讨论最大值。）
4. 我第一眼做 SC 的方法.jpg 考虑每次选一个还没被覆盖的，然后把所有元素全部覆盖。这样每次覆盖的集合两两不交，那么如果有 $m$ 个集合答案就至少是 $m$，而我们又只用了 $bm$ 个元素。
5. 众所周知贪心是 avg+max 的，这里就只有 350/300。
6. 把自己的全部当 slow 贪心，把最优解全当 fast 算下界，那么是 $\frac 32*2=3$ 倍。
7. 上界是 $v/m$，那么贪心放放到 $v/2m$ 就跑路，或者每次放最小的就行。反例就经典的 $3,3,2,2,2$。
8. Yes. 考虑记录当前每个最优解中集合已经放进去了多少，每次选最小的加一个进去这样就能保证放到最小的上来。如果有多个集合已经放进去的数个数相同，那放错了也不影响（它们等价）。或者说一个集合只关心已经放进去的数的大小和还有多少没放进去。
9. 每个匹配最多覆盖三个最优解中匹配，所以随便放就对了。
10. （好像(a)也不难想到）考虑贪心的过程就能证明 (a)，然后考虑把每个最优解中没被选到的点的代价平摊到 (a) 选出来的点上，显然在最优解中的点不可能再被平摊，同时每个点最多平摊 $4$ 次。（界是紧的，考虑就五个有权值的点的情况）
11. 这下就对着重量取整了。
12. 完全复刻 Set Covering.jpg 考虑每一步加一个集合覆盖部分没有被覆盖的点（此时每个点代价定义为加进来的集合权值加上连接权值平摊到每个点）或者把一个点连到一个集合（代价是连接代价）。贪心就每次找一个操作最小化平均代价，对于第一种操作显然最小化平均代价应该把能覆盖的点的连接代价排序然后拉进来。然后类似地考虑选了 $i$ 个点后的情况，把最优解的覆盖拉过来，那么总共用不超过 $w_n$ 的代价就能覆盖剩余点，因而一定存在一步平均代价不超过 $\frac {w_n}{n-i+1}$，求和就是调和级数。

xtq orz

还有一个话题是 inapproximability，其结果类似于说 $k$ 倍近似某个东西是 NP-H 的。但这东西太过于难了。


#### Day 18+25 (10/5+10/12)

加速.gif

Chapter XIII : Randomized Algorithm

说到随机，我们有两种随机的情况：第一种是算法确定，但输入随机；此时我们可能能分析出更好的平均复杂度。更好玩的情况是算法中使用了随机，这里我们会更多地考虑后者。

我们不仅可以对 NP-C 考虑这件事，还可以考虑 poly 算法在随机下能不能更简单或者更快（例如 Miller-Rabin）。

随机化还在一些神必地方有用：对于 multi-agent 的问题，随机可以避免所有人操作相同，这是非常有意义的。

multiagent经常是概率论小练习，这里就跳过了。

很遗憾的是随机的分析很难，所以这里讲的都是比较 naive 的东西。

谨记：我们不一定直接用随机解决问题，随机的性质也有可能得到别的结果。

##### Global min-cut

给一个可以带权的无向图，找到全局最小割。

显然我们有直接网络流的做法，但这里有一个极其简单的随机做法：

考虑每次（按照边权权重）随机一条边，钦定这条边两个端点在最小割同侧，然后缩起来，直到只有两个点。

考虑这样的正确率。注意到一种最小割是一侧只有一个点，考虑把每一个这样的割加起来，那么最小割的 $n$ 倍不超过这 $n$ 个割的和，也就是总边权的 $2$ 倍。因此最小割小于等于边权的 $\frac 2n$。

那么可以发现，这次合并错误的概率是 $\frac 2n$，每一步都不错的概率是乘起来，也就是 $\binom n2^{-1}$。因此跑 $O(n^2)$ 遍就有了常数正确率，复杂度 $O(n^2m)$（但是很难跑得过网络流）

听说有更高明的随机，但我不会。

这也有一个直接的推论：全局最小割的数量不超过 $\binom n2$。

证明：注意到上述分析是对于一个最小割考虑的，即它返回这个最小割的概率至少是 $\binom n2$。然后直接结束了。

这个结论就很震撼了。可以发现上界正好由一个大环取到。

基础概率论.jpg

##### Max 3-SAT

给一个满的 3SAT，求最多能满足多少个 clause。

naive 想法：直接随。

可以发现期望能满足 $\frac 78m$ 个 clause。那我们直接得到如下结论：

1. 至少能满足 $\frac 78m$ 个，这显然是紧的（考虑 $8$ 个满 clause）。
2. 考虑随到满足条件的概率。注意到小于它最少小于 $\frac 18$，多于它最多多于 $\frac 18 m$。因此至少有 $\frac 1{8+m}$ 的概率解大于它。那么随机 poly 次就对了。

##### n-th element

给一个没排序的序列，求第 $k$ 大。

众所周知的算法是每次随机一个位置然后按照大小做线性划分。

经典的分析方式是可以发现每次至少有一半的概率变成 $\frac 34$ 以内。严谨一点就按照 $\frac 34$ 分段，每一段期望停留两次，那么随便就能放缩到 $O(n)$

##### quick sort

众所周知：随机一个位置按大小划分，两侧递归。

有一万种分析方式。这里是考虑一个修改后的算法：随机直到随到 $\frac 34$ 划分再递归。显然后者应当是 $O(n\log n)$ 的，然后直接递归显然不超过有时候暂停。

##### Hashing

啥高明的都没讲.jpg

##### Closest Pair of Points

给一个二维平面，求最近点对。

不随机的分治：

随机的网格：考虑依次加点，设当前最短距离为 $l$，那么按照 $\frac l2$ 分网格。这样每个格子内最多一个点，同时每个加入一个点只需要看附近 $O(1)$ 个网格。如果距离减小我们需要减少网格。随机的想法是我们随机顺序加入点，这样最短距离只会改变期望 $O(\log n)$ 次。证明：每一步有 $\frac 2n$ 的概率拿走取到最短距离的点。同时可以发现每次重构代价的期望是 $1$（有 $\frac 1i$ 的概率需要 $i$ 的代价），那么期望就是 $O(n)$ 的。

网格也可以做到不随机，但这样多 log。虽然这样的确定性可以拿来做区间最近点对。

##### Caching

考虑 $n$ 个物品和一个大小为 $k$ 的 cache。然后进行 $q$ 次访问 cache，如果 miss 则必须要把对应东西拿进来替换掉一个位置。我们希望最小化 miss 次数。

可以证明最优解是每次删掉下次访问最晚的东西。我们不能预知未来的情况，但我们还是希望我们的算法能 bound 住最优情况。

问题是这东西步数很难分析，我们尝试找到一些形式和bound。考虑如下形式的算法：

考虑 mark 一些物品，每次加入物品时进行 mark，每次需要 evict 时尝试拿掉一个没有 mark 的物品。如果加一个物品前 mark 满了就清空 mark。我们称第 $i$ 次清空 mark 前的部分为第 $i$ 阶段。

那么我们可以得到如下结论：

1. 设总共经过了 $r$ 个阶段，则 miss 数量不超过 $kr$。证明：每阶段进行 $k$ 次 mark，每 mark 一个物品最多 miss 一次，也可以不 miss。
2. 最优解至少会有 $r-1$ 次 miss。证明：考虑阶段划分，如果一个阶段拿进第一个物品后就没有 miss 过，那这个阶段结束时 cache 内部必定是所有 mark 的东西，那么下一步必定 miss。因此每阶段会 miss 一次。

那么我们直接得到了一个 $k$ 倍级别的 bound。基于此我们可以得到如下结论：

LRU 最坏不超过最优解的 $O(k)$ 倍。这个级别是可以达到的，构造就用最经典的循环 thrashing。证明：显然 LRU 不会先拿有 mark 的东西。



但随机算法还可以得到更好的界。考虑如下极其简单的随机算法：

我们在每个阶段中每次 replace 时，随机一个没有 mark 的物品进行 replace。

可以发现最优解和我们的算法中每一个阶段内的物品不会在阶段内被换出去（因为最优解是换下次最晚的），那么我们可以认为每一阶段正好有 $k$ 次不同的请求。

为了更好的分析，我们首先需要一个更好的下界。此时有非常神奇的构造：

我们称在第 $i$ 阶段中一个请求的物品是新的，当且仅当它在上一轮中没有出现。（换言之，一轮不出现的物品就变回新的了）记 $c_i$ 表示第 $i$ 阶段的新物品数量。

然后有神奇的结论：

最优解中 miss 次数不小于 $\frac 12\sum c_i$（！!1）

证明：考虑相邻两个阶段，可以发现有 $k+c_i$ 种不同的物品，那么这两阶段内就会 miss $c_i$ 次。那么全部求和除以 $2$ 就是一个下界。

那么我们只需要拿 $\sum c_i$ 去尝试 bound 下界。我们的想法是对每个阶段单独分析。好消息是上一阶段中访问过的物品都会留下来（算法保证），那么我们确实可以分开分析。

考虑一个阶段。这一阶段中有 $c$ 个新物品，剩余物品当前都在 cache 中，但没有 mark。然后我们会将所有物品按照之前的方式全部放进来。每一步我们都会让没有被 mark 的物品减少一个。如果这次加入的物品之前还留在里面则我们直接把它 mark 且不增加 miss 次数，否则我们随机删掉一个没有 mark 的物品然后增加 miss 次数。

每步操作都是随机删一个剩余的物品。那么可以发现所有没有被 mark 的旧物品出现概率相等，因此一步访问旧物品时 miss 的概率等于被移出 cache 的旧物品数量除以当前没被 mark 的旧物品数量。但可以发现被移除的旧物品数量等于加进来的新物品数量（守恒），那么这个概率不超过 $\frac{c_j}{ls}$。可以发现当前还没被 mark 的旧物品数量是从 $k$ 一路降到 $c_j$ 的。因此总的 miss 数量是新物品的 $c_j$ 次加上旧物品的 $c_j*(\frac 1{c_j+1}+\cdots+\frac 1k)$，那么这不超过 $c_j$ 的 $1+\frac 12+\cdots+\frac 1k$ 次。（！!1）

因此我们得到了一个 $2(1+\frac 12+\cdots+\frac 1k)=O(\log k)$ 倍的近似结果。可以发现这比 lru 的最坏情况好多了，但我相信实践中没人写这个。



##### Probability Theory Practice

###### 1

给 $n$ 个物品，随机分到 $n$ 个位置中（每个物品独立随机），我们需要分析分到物品最多的位置分到了多少个。换言之，考虑分到的最大的大于 $c$ 的概率。

多个物品过于难分析，考虑直接 union bound，只考虑第 $1$ 个位置大于 $c$ 的概率，实际概率不会超过 $n$ 倍。

如果只考虑一个位置，那就是每一个物品有 $\frac 1n$ 的概率加到上面。因此我们拿出经典的 chernoff bound：

$$
Pr[x\geq C]\leq \frac{e^{c-1}}{c^c}(c\geq 1)
$$

我们希望 $\frac{e^{c-1}}{c^c}$ 很小。提取一个常数出来就变成 $\frac{e^c}{c^c}$。令 $t=\frac ce$，则变成 $t^{-et}$。那么我们需要 bound $t^t$。可以发现只需要这东西是一个 $n$ 量级就够了，因为这样这个概率就是 $n^{-e}$，乘一个 $n$ 也够了。显然 $t$ 是 $O(\log n)$，但还可以继续分析。

考虑 $t^t=n$，随便取点 $\log$ 就有 $t\log t=\log n,\log t+\log\log t=\log\log n$。那么 $2\log t\geq \log\log n$，除回去就得到了 $t=O\left(\frac{\log n}{\log\log n}\right)$。

当然我们也可以让物品数更多，这样 $\mu$ 的幂次就可以冲掉底数。进一步可以得到只需要 $n\log n$ 级别的物品就可以让每个数在平均值的 $2$ 倍之间。



不管如何先把这部分写完。

###### 2

考虑一个图，有 $n$ 个物品，每个物品有一条预定的路径。每个时刻每条边只能经过一个物品，你可以决定每个时刻每条边上（如果有多个物品堵在这）哪个物品过去。

我们的目标是希望在尽量少的时间中将所有物品沿着预定路径移完。首先考虑这个步数会是什么情况。我们记 $d$ 表示最长的路径长度，$c$ 表示每条边被经过次数的最大值。那么显然的下界是 $\max(c,d)=\Omega(c,d)$，但如果我们naive地放，很容易被卡到 $\Omega(cd)$：考虑一个 $c$ 叉树，每个叶子往上，每个子树内只有最左侧的叶子会继续往上走。如果每次选最差的，那么每一层上所有向上的点都会卡 $d$ 步，但如果每次选最好的就是总共 $c+d$ 步。所以我们不能 naive。

这里我们考虑一个随机算法，它虽然不能做到 $O(c+d)$，但只多了一个 log：

naive做法的问题是一个物品被阻挡了之后接下来的时序就全乱了，然后它就能继续阻挡其它东西导致完全崩盘。一个 naive 的想法是我们直接要求每个物品一定不被阻挡：我们给每个物品选定一个开始时间，然后干这件事。但这实在是不太可能在很小的时间内解决。那么我们考虑找一个“不被阻挡”的折中点：

考虑将时间按照 $b$ 分块，对于每个物品，我们要求它在每个 block 内需要移动一次（多出来的移动可以直接吃掉）。然后我们钦定一个 $r$，让每个物品先随机等待若干个 block，然后再开始前进。

可以发现这个算法失败当且仅当某个时间某条边上有超过 $b$ 个人想经过。我们只需要分析这种情况出现的概率。

注意到每个路径随机了一个起始时间，那么对于任意时刻，每个物品在这个时刻需要经过这条边的概率不超过 $\frac 1r$。那么 $c$ 个独立随机物品，每个 $\frac 1r$ 概率，需要不超过 $b$ 个，那么我们自然想到 chernoff bound：考虑第二种形式，如果 $c$ 是至少 $r\log r$ 级别的，那么只要 $b$ 超过 $\frac cr$ 的某个常数倍则溢出的概率可以任意小。注意我们还需要考虑总事件数，但因为chernoff可以指数，这里 poly 大一点其实没啥影响。那么我们大力 bound 一个 $nm$，其中 $m$ 是总边数。（我们隐式地要求 $r\leq n$：我们相信最优解不会拖那么久。）

后面地构造就比较随意了：我们希望 $r$ 是 $c$ 除以一些东西，这里我们令 $r=\frac c{q\log nm}$，然后直接拿出 chernoff，按照之前的想法：

$$
pr[ct\geq (1+\delta)\frac cr]\leq (\frac{e^{\delta}}{(1+\delta)^{1+\delta}})^{c/r}\\
\leq (\frac{e^{1+\delta}}{(1+\delta)^{1+\delta}})^{c/r}\\
\leq (\frac{e}{(1+\delta)})^{(1+\delta)q\log nm}
$$

这里的放缩和上一步完全一样。然后我们让 $\delta>e-1$（比如取 $2$），然后里面就 $<1$ 了，然后就是 $(nm)^{-d}$ 之类的感觉。我们让 $q$ 取大一点（但还是常数），这样就 bound 住 $nm$ 倍了。

然后我们有 $b=\frac {3c}r$，所以步数是 $b(r+d)=3c+d*\frac{3c}r=O(c+d\log mn)$，这里认为 $q$ 是常数。可以发现我们只多了一个 $\log$ 倍。

##### Exercises

1. 直接随就是期望正确，但是需要 $O(n)$ 次。当然也可以按顺序贪心。
2. 分类考虑。
3. 只需要证明相邻两个不冲突，然后线性性。(a)显然，然后 $n/2^{d+1}$。(b)显然，然后 $n*p*(1-p)^d$。接下来求个导就行，我懒得算了。
4. 显然期望是 $\frac 1i$ 的后缀和。然后倒着推，每一步不连的概率正好是 $\frac i{i+1}$ 乘起来，所以是 $\sum \frac in$。
5. 期望线性性一下，$j$ 付第 $i$ 段的钱当且仅当 $j$ 比 $i,\cdots,n$ 中的其它位置出现的都早（后面的出现了他就不付钱了，前面的出现了就不付这一段了），那么正好是第三个。
6. 直接随就是 1/3。Note：如果有满足所有情况的解，那么我们可以 $\frac 12$：考虑答案从左往右依次拿进来，那么每个组合第一个拿进来的位置不是中间那个。因此存在排列满足这一性质，那么我们可以贪心搞出这样的排列。然后考虑反向加回去，每个数加进去时完成的组合中它都不在正中，那么向两侧更大的那个加即可。
7. (a)就单变量拉满。(b)注意到双变量就是 $\frac 34$，考虑平衡一下：如果有一个单变量，那么它 $\frac 35$ 概率取这边，$\frac 25$ 概率不取这边。这样剩下的正确率也至少是 $1-(\frac 35)^2\geq \frac 35$，进一步可以做到 $0.618$ 那个数。(c)如果有矛盾的，直接配对删掉，最后加回来时我们和std都增加 $1$ 所以不差。
8. 首先随机确实是对的，因为解的优秀程度差距是 poly 倍。如果不考虑集合大小我们可以流，但考虑集合大小就不会了。
9. 典题。做到 $1/4$ 就考虑前一半 reject，然后拿接下来第一个比前面都大的。有至少 $\frac 14$ 的概率第二大的在前面，最大的在后面。但是更优的是前 $1/e$ reject，这时答案也是 $1/e$ 左右的，可以参考auoj471。
10. 线性性。调和级数。
11. (a) $(1-1/k)^k$，所以是 $e^{-1}$。(b)可以发现就是上一问的结果。(c) 考虑回去强行展开 $((\frac {n-1}n)+\frac 1nx)^n$ 的前两项，那么我们有 $(\frac {n-1}n)^n+(\frac {n-1}n)^{n-1}*\frac 1n*n$ 的概率只拿到 $<2$ 个工作，因此有 $1-2e^{-1}$ 的概率少拒绝一个工作。因此是 $3e^{-1}-1$。
12. 之前的证明无效的原因是之前每个点的度数都可以贡献到最小割，那么考虑构造小度数。考虑若干长度为 $2$，边权 $1+2$ 的 $s$ 到 $t$ 的链，每条链有 $\frac 13$ 的概率错误，那么正确率是 $(\frac 23)^n$。
13. 直接算方差然后Chebyshev。或者叫大数定律。
14. 考虑一个 $2n-1$ 个元素的集合 $S$，那么 $S+a,S+b$ 就钦定了 $a,b$ 在同侧，然后多堆几个把这些 $a$ 放在同一个集合就寄了。但这里数量有限制，所以作为替代我们可以造 $2n-3$。然后直接随，拿 chernoff bound 就行。
15. 考虑中位数大于 $0.51$ 的概率（另一边 union bound），那么每次选择有 $0.49$ 的概率 $+1$，要求不超过 $0.5n$，所以chernoff就行。
16. 依次算每一位，每次对的人至少是 $\frac 34$，那么 chernoff 一下就很对。
17. 看成每次 $\pm 1/2$，但是再减 $1/6$ 这事就显然了。虽然具体分析需要严谨地 chernoff。
18. 权值情况不太现实。无权情况根本不会做，但是hint给完了。考虑每条边选中的概率，显然答案不超过这个求和。考虑每个点相邻边的概率和。每有一条相邻边被选中就有 $\frac 12$ 的概率选到当前点（这样之后绝对不会再选了），那么期望不超过 $2$，所以答案不超过 $2$ 倍点覆盖。





