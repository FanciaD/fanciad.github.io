---
title: Numbers Rearranging
date: '2023-10-15 17:04:38'
updated: '2023-10-15 17:04:38'
tags: Fancia Mildia
permalink: WindCrying/
description: Numbers Rearranging
mathjax: true
---


#### Numbers Rearranging

##### Problem

有 $m$ 个数，考虑如下通信过程：

Alice 会拿到这 $m$ 个数中的 $n$ 个，然后她需要将这 $n$ 个数任意排序，将得到的序列给 Bob。

Bob 不能直接看这个序列。他会拿到一个 $[1,m]$ 间的 $x$，然后他可以选择一个位置，看序列这个位置的值。在得到这个值之后，Bob 需要回答 $x$ 是否出现在序列中。

现在请问，对于 $n\geq 3$，$m$ 最多能做到多少？

##### Upper Bound

Bob 的策略看起来更简单：对于每一个 $x$ 我们会先确定一个询问的下标，然后的决策是一个 $[1,m]^2\to \{0,1\}$ 的函数，左侧是 $x$ 和询问的结果。

但直接分析看起来非常难：一个位置的信息熵看起来可以有 $O(\log m)$，但我们只需要回答一个 bit。这样好像啥都证不出来。

但可以发现 Bob 的策略是确定的，如果有 $d$ 个 $x$ 走到同一个下标，那么这个下标就必须能提供 $d$ 个 bit 的信息熵。这样我们直接得到了一个 $O(n\log n)$ 的上界：如果超过这个上界，那么有 $\log m$ 位到同一个下标询问，$m$ 个数不能区分这么多情况。（注意这里只是粗略分析，因为我们要编码还需要考虑这 $m$ 个数是否出现之类的）

但注意到我们只拿进来 $n$ 个数，还可以任意安排。那考虑安排掉 Bob 的策略。Bob 需要编码 $2^d$ 种情况，我们考虑在知道 Bob 用每个数分别对应哪种情况后，选一种情况让这种情况的数都不出现，这样就寄了。但这里因为我们要拿 $d$ 个数编码情况，因此我们不能安排这 $d$ 个数。那 Bob 可以用这 $d$ 个数解决 $d$ 种情况，还剩 $2^d-d$ 种情况只能用别的数编码。这样一定有一种出现次数小于 $\frac 1{2^d-d}$。在 $m\geq (d-1)n+1$ 时，我们一定有一个取到 $d$，但这样我们可以至少拿掉 $\frac 1{d-1}$ 的数，因此直观上看 $d=3$ 的时候就 $\frac 12>\frac 15$ 了，因此有 $m\leq 2n$。这样分析虽然对很大的 $n$ 都显然正确，但对于很小的 $n$ 可能常数会超过主项。但可以发现即使 $n=3,m=7$，都不出现的情况也可以再扔一个数所以需要 $2$ 个标识，剩下的需要 $3,3,3,4,4,4,5$ 个标识，但选出 $5$ 个加起来显然炸了。因此 $n\geq 3$ 时我们就有 $m\leq 2n$。

考虑 $2n$ 级别的情况，刚才的分析说明 $d=3$ 看起来很烂，因此我们希望都让 $d=2$。考虑所有 $d_i\leq 2$ 的情况。那么每个 $d=2$ 的位置有四种情况。设这两个数是 $a,b$，那么 $a,b$ 可以分别去掉两种情况。考虑不被 $a,b$ 标记的情况，此时如果是都不出现则可以再删 $m-n-2$ 个数，所以需要 $m-n-1$ 个标记，类似的出现一个需要 $m-n$ 个标记，所以 $m<(m-n)+(m-n-1)+2$ 则无解，即 $m>2n-1$ 无解。然后考虑 $m=2n-1$。此时可以发现因为我们卡满了，所以每一个二元组 $(a,b)$ 一定是如下形式：$a$ 对应只出现 $a$，$b$ 对应 $ab$ 都出现，然后剩下的 $n-1$ 个放在 $b$ 出现，$n-2$ 个放在都不出现。此时我们只剩一个额外位置 $x$。考虑拿一个二元组出来安排构造：如果 $x$ 对应都不出现，那考虑这一组让 $b$ 出现，然后剩下每一组出现 $a$（这样 $a$ 必须对应自己的对），这样这一组就寄了。但如果 $x$ 对应 $b$ 出现，好像一时推不出矛盾。但此时可以看出每一组都应该 $x$ 对应 $b$ 出现。

注意到一组可以通过只出现 $a$ 使得这组对别的没有影响（包括 $m-n$），那么考虑只有一对 $a,b$ 都出现和一个不出现的 $x$，那么 $x$ 上出现 $a$ 代表 $x$ 不出现。同时拿走其它所有对就会发现 $x$ 上出现 $x$ 代表 $x$ 出现。再考虑只出现一个 $b$ 和 $x$，那么可以发现出现 $b$ 对应出现。

然后考虑 $x$ 出现，一对 $(a_1,b_1)$ 都出现，一对 $(a_2,b_2)$ 都不出现。这样 $x$ 只能放在原位，然后只能 $a_1\to$ 第二对，从而每一对上出现别的 $a_i$ 都表示两个数都不出现。这样两个都不出现的 $n-2$ 个位置就被占满了，然后其它 $b_i$ 和 $x$ 都对应只有 $b$ 出现。

但这样存在一个问题：只有其它 $b_i$ 可以过来代表 $b$，那考虑有一对 $(a,b)$ 都出现，另一对只出现 $b$。这样必须第一对的 $a$ 去放在 $x$，然后只能第二对的 $b$ 放在自己，但这样就寄了。那么在只用 $d=1,2$ 的情况下，我们不能做到 $2n-1$。

之前我们分析了 $d\geq 3$ 的情况也很难成立，但这对很小的 $n$ 不大成立。例如 $n=3$ 的时候我们可以取 $d=3$（只需要在第一个位置放唯一不出现的数的下一个数即可），但这样不会导致更优的结果。可以发现在 $n=4,m=7$ 的情况下，都不出现的情况下只需要 $1$ 个，然后需要 $2,2,2,3,3,3,4$，这样最坏需要 $8$ 个所以也不行。唯一的问题出在 $n=3,m=5$，直接分析分析不出来，但可以搜出来无解。

那么我们可以得到如下结论：$m\leq 2n-2$。

##### Solution

然后我们考虑 $m=2n-2$ 的情况。可以发现这看起来是有解的。结合之前的若干提示，我们容易发现一些方法：

和之前一样，考虑分出 $n-2$ 对 $(a_i,b_i)$，以及两个额外元素 $x_1,x_2$。考虑一种不同于之前的方式：让 $a$ 放在这个位置代表只有 $a$ 出现，$b$ 放在这个位置代表只有 $b$ 出现，都出现的情况和都不出现的情况用其它数区分。

和之前的情况类似，如果 $x_i$ 放过来表示空集那看起来不大行，因此 $x_i$ 放到前面一定表示都出现。类似之前的想法，我们让其它的 $b_i$ 表示都出现，其它的 $a_i$ 表示都不出现。对于 $x_i$ 我们让 $x_i,b_i$ 表示出现，$a_i$ 表示不出现。

那么直接地想，我们把只有单个出现的全部先处理掉，然后 $b_i$ 内部填，$a_i$ 填到那些两个都没出现的位置和没出线的 $x_i$。唯一的问题出在 $b_i$ 内部，只有一对都出现的情况。但可以发现此时两个 $x_i$ 不可能都不出现（否则就有两对了），那么此时和某一个 $x_i$ 换位即可。（上一种情况就差在这里）。

##### Code

```cpp
#include "numbers.h"
int n;
void init(int _n)
{
    n=_n;
}
vector<int> arrange(vector<int> a)
{
    vector<int> occ(n*2-1),res(n);
    for(int i=0;i<a.size();i++) occ[a[i]]=1;
    vector<int> s1,s0;
    for(int i=1;i<=n-2;i++)
    {
        if(occ[i*2-1]!=occ[i*2])res[i-1]=i*2-1+occ[i*2];
        else if(occ[i*2])s1.push_back(i*2),s0.push_back(i*2-1);
    }
    int nw=1;
    for(int i=1;i<=n-2;i++)if(occ[i*2]&&occ[i*2-1])res[i-1]=s1[nw%s1.size()],nw++;
    for(int i=1;i<=n-2;i++)if(!occ[i*2]&&!occ[i*2-1])res[i-1]=s0[nw%s1.size()],nw++;
    for(int i=n-1;i<=n;i++)if(occ[n-2+i])res[i-1]=n-2+i;else res[i-1]=s0[nw%s1.size()],nw++;
    if(s1.size()==1)
    {
        int v1=s1[0],fr=v1/2-1;
        for(int i=n-1;i<=n;i++)if(res[i-1]==n-2+i)swap(res[i-1],res[fr]);
    }
    return res;
}

int getid(int x){return x>n*2-4?x-n+2:(x+1)/2;}
bool count(int x)
{
    int id=getid(x);
    int res=query(id);
    if(getid(res)==id)return res==x;
    else return res>n*2-4?1:res%2==0;
}
```