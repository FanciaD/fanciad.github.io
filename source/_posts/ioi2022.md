---
title: IOI2022 题解
date: '2022-08-29 13:28:33'
updated: '2022-08-29 13:28:33'
tags: Mildia
permalink: Testify/
description: IOI 2022
mathjax: true
---


#### Fish

##### 算法一

记 $h_i$ 表示在一种方案中，第 $i$ 列修建的高度。

可以发现如果确定了 $h_{i-1},h_i,h_{i+1}$，就可以确定第 $i$ 列被抓住的鱼，具体来说，第 $i$ 列的贡献为这一列中高在 $(h_i,\max(h_{i-1},h_i,h_{i+1})]$ 中的鱼的重量和。因此考虑设 $dp_{i,a,b}$ 表示考虑了前 $i$ 列，$h_i=a,h_{i-1}=b$ 时前 $i-1$ 列的最大贡献，转移时枚举下一列的高度，可以预处理后 $O(1)$ 计算系数。复杂度 $O(n*(\max y)^3)$，可以通过子任务 $3,4$。

##### 算法二

记 $s_{i,j}$ 为第 $i$ 列中高度不超过 $j$ 的鱼的重量和，则第 $i$ 列贡献为 $s_{i,\max(h_{i-1},h_i,h_{i+1})}-s_{i,h_i}$。

因为 $s_i$ 单调不降，贡献可以看成 $\max(s_{i,h_{i-1}},s_{i,h_i},s_{i,h_{i+1}})-s_{i,h_i}$。因此最大化贡献可以看成如下问题形式：

> 在确定了 $h_i$ 后，对于每个 $i$，选取 $g_i\in\{h_{i-1},h_i,h_{i+1}\}$，最大化 $\sum_{i=1}^n s_{i,g_i}-s_{i,h_i}$。

考虑对于一个确定的 $h$ 求最大收益，可以设 $f_{i,0/1}$ 表示考虑了前 $i$ 列，是否要让 $g_i=h_{i-1}$ 时前面部分的最大收益，转移时枚举 $g_{i+1}$ 的选取情况即可。这样的好处是第 $i$ 列的转移只需要 $h_i,h_{i-1}$。

考虑在原问题中使用这一方式，设 $dp_{i,a,0/1}$ 表示考虑到第 $i$ 列，$h_i=a$ 且是否让 $g_i=h_{i+1}$ 时前面部分的最大收益。转移时枚举 $h_{i+1}$ 及 $g_{i+1}$ 的选择情况，同样可以 $O(1)$ 转移。复杂度 $O(n^3)$，可以通过子任务 $4,5$。

##### 算法三

考虑上一种算法中的转移，可以发现对于一种转移（一种 $g_i,g_{i+1}$ 的选择情况），转移时新增的贡献为两部分之和，其中第一部分只和 $h_i$ 相关，另外一部分只和 $h_{i+1}$ 有关。

那么这一种转移时可以先枚举之前的所有状态，找到 $dp_{i,a}$ 加上与 $h_i=a$ 相关系数的和的最大值，再对于每一个 $b$，用这个最大值加上与 $h_{i+1}=b$ 相关系数更新 $dp_{i+1,b}$。

这样转移复杂度变为状态数线性，复杂度变为 $O(n^2)$，可以通过子任务 $4,5,6$。

##### 算法四

考虑子任务 $7$，即每列的鱼数量不超过 $2$。

由于每列修建的高度只影响这一列以及相邻两列的贡献，可以发现如下结论：

> 存在一种最优方式，使得对于每一个 $i$，$h_i$ 取 $0$ 或者 $i-1,i,i+1$ 列中某一条鱼的高度。

证明：对于一个不满足条件的 $h_i$，将它降低到这三列中高度小于在当前的 $h_i$ 且最高的鱼的高度（或者 $0$），不改变这种方式的收益。

因此在子任务 $7$ 中，每一列只需要考虑不超过 $7$ 种高度，可以使用之前的任意一种 dp 做到 $O(n)$ 复杂度。



在原问题中，这一性质说明对于如果对于每一列使用这种方式得到这一列需要考虑的高度，则总的状态数为 $O(n+m)$。

而上一种算法中可以以状态数线性的复杂度进行转移，结合这两者即可做到 $O(n+m\log m)$ 复杂度（瓶颈在于排序），可以通过所有子任务。

<div STYLE="page-break-after: always;"> </div>

#### Prison

##### 算法一

考虑将 $a,b$ 看成二进制数，从高到低比较每一位。如果当前位不同则可以得到大小关系，否则继续比较下一位。

首先考虑比较一位的情况，可以发现使用三种数能完成比较。例如，设使用的数为 $0,1,2$，则可以使用如下策略：如果当前数为 $0$，则选择查看 $a$，如果 $a$ 的这一位为 $0$ 则将数改为 $1$，否则将数改为 $2$。如果当前数为 $1,2$，则可以知道 $a$ 这一位的值。此时选择查看 $b$，可以比较 $a,b$ 在这一位的大小关系，然后判断大小关系或者继续比较下一位。

考虑对于每一位使用三种数，这样可以得到一个 $x=3\lceil\log_2 n\rceil-1$ 的做法，例如：

使用数 $0,\cdots,3\lceil\log_2 n\rceil-1$。使用如下策略：

1. 如果当前数为 $3*d$，则查看 $a$ 从低到高的第 $\lceil\log_2 n\rceil-d$ 位（从 $1$ 开始编号），并根据这一位将数改为 $3*d+1,3*d+2$ 中的一个。
2. 如果当前数为 $3*d+1,3*d+2$，则查看 $b$ 从高到低的第 $\lceil\log_2 n\rceil-d$ 位，根据这一位和由当前数得到的 $a$ 的这一位判断大小关系或者继续比较（此时将数改为 $3*d+3$）。

这样可以做到 $x=38$，得分 $38$。

可以发现二进制不是最优的，可以取不同进制做到更优，例如取 $4^5*5=5120$，可以做到 $x=5*5+6-1=30$，得分 $50$。

##### 算法二

上一个算法相当于使用数依次传递 $a$ 的每一位，由下一个人查看 $b$ 并判断，这只传递了 $a$ 的信息。考虑同时传递 $a,b$ 的信息，例如如下策略：

使用二进制的方式作为例子，考虑使用数 $0,1,\cdots,2\lceil\log_2 n\rceil$。使用如下策略：

1. 如果当前数为 $0$，则选择查看 $a$ 的二进制第 $\lceil\log_2 n\rceil$ 位，根据这一位将数改为 $1,2$ 中的一个。
2. 如果当前数为 $1,2$，则可以知道 $a$ 的二进制第 $\lceil\log_2 n\rceil$ 位，此时查看 $b$，可以根据 $b$ 的这一位判断这一位上的大小关系。如果这一位相同，则根据 $b$ 的下一位（即 $\lceil\log_2 n\rceil-1$ 位），将数变为 $3,4$ 中的一个。
3. 如果当前数为 $3,4$，则知道了 $b$ 的二进制第 $\lceil\log_2 n\rceil-1$ 位，那么使用与上一步类似的方式查看 $a$ 并进行操作。接下来的过程类似。

这样可以做到 $x=26$，得分 $56$。

同样地，这里可以取 $3^6*2^3=5832$，做到 $x=24$，得分 $65$。

##### 算法三

考虑上一种策略。因为两个数不同，可以发现如果比较到了二进制的最后一位，则当前操作的人不需要将当前数的最后一位传递给下一个人判断，而是可以直接判断出大小关系：如果当前数最后一位为 $0$，则显然另外一个数这一位为 $1$，因此当前数更小，另外一种情况类似。这样可以不用最后两种数，即将 $x$ 减二。

对于三进制的情况也可以类似地减二：如果当前数在三进制下最后一位为 $0$ 则可以直接判断当前数小，如果为 $2$ 则可以直接判断当前数大，否则考虑写一个数，将这一位为 $1$ 的信息传递给下一个人。这样可以少用两种数。

使用这一优化可以做到 $x=22$，得分 $80$。

通过进一步的特判（例如用两种数判断 $0\sim 5$ 的大小关系），可以做到 $x=21$，得分 $90$。

##### 算法四

换一种角度考虑算法二。这个过程可以看成确定 $a,b$ 所在的区间 $[l,r]$。当一个人进行操作时，他先将当前区间分成 $k$ 份，然后通过 $k$ 种数传递 $a$ 在哪一份区间内。

下一个人操作时查看另外一个数，首先判断 $b$ 在哪一个区间内。如果 $a,b$ 不在一个区间内则可以直接判断出大小，否则对 $a,b$ 所在的这个更小的区间重复之前的操作。

上一个算法中的优化相当于在最后几步进行了特殊处理，如果当前数是可能值域内的最小值或者最大值则直接判断出大小关系。考虑对每一步都使用这种做法。即如下策略：

考虑当前 $a,b$ 都在的区间 $[l,r]$，初始 $[l,r]=[1,n]$。

一个人操作时，如果当前数等于 $l$ 则直接判断当前数更小，等于 $r$ 则直接判断当前数更大。

否则，将 $[l+1,r-1]$ 分成 $k$ 个区间，用 $k$ 种数传递当前数在哪个区间。

下一个人操作时查看另外一个数，如果这个数为 $l,r$ 则直接判断，否则如果两个数不在同一个分出的区间则直接判断，否则对当前 $l,r$ 所在的区间继续做这种操作。

此时可以发现如果全部取 $k=3$，则可以做到 $x=3\lceil\log_3 n\rceil-3=21$。

但还有更优的方式，一种方式是依次取 $k=3,3,3,3,3,2,2,1$，这样能在 $x=20$ 内解决 $n=5588$ 的问题。得分 $100$。

<div STYLE="page-break-after: always;"> </div>

#### Towers

这里给出一种与官方做法不同的做法。

##### 算法一

首先考虑判断一种方式合法的条件。可以发现如下结论：

> 选择的信号塔能两两通信当且仅当选择的信号塔按照编号从小到大排序后，相邻的两个信号塔间都能通信。

证明：充分性显然。考虑三个信号塔 $a,b,c(a<b<c)$，如果 $a,b$ 能通信且 $b,c$ 能通信，则存在 $p\in[a+1,b-1]$ 使得 $h_p\geq d+\max(h_a,h_b)$，存在 $q\in[b+1,c-1]$ 使得 $h_q\geq d+\max(h_b,h_c)$。那么 $h_p,h_q$ 中最大的一个一定满足高度大于等于 $d+\max(h_a,h_b,h_c)$，因此 $a,c$ 可以相互通信。这样即可证明必要性。



那么可以发现选择信号塔相当于在区间内找到一个递增的下标序列 $i_1,\cdots,i_{2k-1}$，使得 $h_{i_1}+d\leq h_{i_2},h_{i_2}\geq h_{i_3}+d,h_{i_3}+d\leq h_{i_4},h_{i_4}\geq h_{i_5}+d,\cdots$，选择的信号塔为 $i_1,i_3,\cdots,i_{2k-1}$。选择尽量多的信号塔相当于选择尽量长的满足条件的序列。称 $i_1,i_3,i_5,\cdots$ 是低位置，其余为高位置。

此时可以得到如下贪心做法：

记录当前选择的最后一个信号塔 $x$ 以及上一个选择的位置是高位置还是低位置。依次考虑每一个位置：

如果上一个选择的位置为低位置，则：

1. 如果 $h_i\geq h_x+d$，则选择 $i$ 作为下一个高位置。
2. 如果 $h_i<h_x$，则将当前选择的低位置改为选择 $i$。
3. 否则不进行操作。

如果上一个选择的位置为高位置，则：

1. 如果 $h_i\leq h_x-d$，则选择 $i$ 作为下一个低位置。
2. 如果 $h_i>h_x$，则将当前选择的高位置改为选择 $i$。
3. 否则不进行操作。

不难证明这样的选择是最优的。直接进行贪心即可得到 $O(nq)$ 的做法，可以通过子任务 $2,3$。

同时对于 $d$ 相同的问题，所有的贪心过程相同，可以对于每个状态预处理出它到达的下一个状态，然后倍增 $O(\log n)$ 处理一组询问。这样可以通过子任务 $4,6$。

##### 算法二

考虑子任务 $5$，即 $l=1,r=n$ 的情况。此时询问区间固定但 $d$ 不同。

首先考虑 $d=1$ 的情况，此时可以发现方案为删去所有满足 $h_{i-1}<h_i<h_{i+1}$ 或者 $h_{i-1}>h_i>h_{i+1}$ 的元素，选择剩余元素。

考虑让 $d$ 逐渐增加。找到使得 $|h_{i_k}-h_{i_{k+1}}|$ 最小的 $k$，则 $d$ 增加到 $|h_{i_k}-h_{i_{k+1}}|+1$ 时，$i_k,i_{k+1}$ 就不能再同时选择。此时考虑使用如下方式调整方案：

1. 如果 $k=1$，则取消选择 $i_k$。
2. 如果 $i_{k+1}$ 是最后一个选择的元素，则取消选择 $i_{k+1}$。
3. 否则，不妨设 $i_{k-1}<i_k>i_{k+1}<i_{k+2}$，则因为 $|h_{i_k}-h_{i_{k+1}}|$ 最小，此时一定有 $h_{i_{k-1}}\leq h_{i_{k+1}}$。考虑取消选择 $i_{k+1}$，然后保留 $i_k,i_{k+2}$ 中更高的一个。

可以发现这种做法得到的方案具有如下性质：

> 对于任意一个 $d$，使用上述做法，在最小的 $|h_{i_k}-h_{i_{k+1}}|$ 大于等于 $d$ 时停止。考虑此时选择的方案，如果 $h_{i_1}>h_{i_2}$ 则删去第一个元素，如果最后一个元素比前一个高则删去最后一个元素，这样得到的方案与上一种算法中得到的方案相同。

证明：首先可以发现，上一种算法得到的方案满足 $i_1$ 是 $[1,i_2-1]$ 中高度最低的，$i_2$ 是 $[i_1+1,i_3-1]$ 中高度最高的，以此类推。

然后可以以此归纳证明，在该算法的每一次调整中，都不会删去一个在上一种算法中选择的元素。这可以通过讨论该算法一次调整中 $i_k,i_{k+1},i_{k+2}$ 是否在上一种算法中被选择，对每种情况分别证明。这里省略讨论细节。

最后，因为上一种算法得到的是一种最优解，因此不存在更优的解，从而此时得到的正好是这组解。



那么，在这个子任务中可以在预处理时进行上述过程，维护答案随着 $d$ 增加的变化，这样即可回答询问。通过数据结构维护，上述过程可以做到 $O((n+q)\log n)$，可以通过子任务 $5$。

##### 算法三

考虑询问为一个区间的情况。重复之前的讨论可以发现，对于一组询问 $(l,r,d)$，在 $[l,r]$ 上使用第一种算法得到的方案和在 $[1,n]$ 上使用这种算法并保留 $[l,r]$ 中部分得到的结果几乎相同，唯一的区别在于端点上的情况。即可能 $[1,n]$ 得到的方案中存在 $i_k<l<i_{k+1}$，不妨设 $h_{i_k}<h_{i_{k+1}}$，则可能存在 $x\in[l,i_{k+1})$，使得 $h_{i_k}<h_x<h_{i_{k+1}}-d$，此时在 $[l,r]$ 中会选择 $x$，但在 $[1,n]$ 中 $x$ 会被 $i_k$ 代替。可以发现只有在两端可能出现这种情况，中间部分（即找到 $i_p<l\leq i_{p+1},i_q\leq r<i_{q+1}$，$[i_{p+1},i_q]$ 部分）的方案一定相同。同时可以发现两侧最多分别多插入一个元素，否则必然矛盾。这里同样省略证明细节。

因此，只需要确定 $i_{p+1}$ 左侧是否能再加入一个元素以及 $i_{q}$ 右侧是否能加入一个元素。可以发现只需要求 $[l,i_{p+1})$ 区间内的最低高度即可判断左侧能否再加入一个元素，另外一侧同理。因此使用 ST 表或类似数据结构维护区间最小值即可处理这种情况。

这里需要找到在这个 $d$ 下区间内选择的第一个和最后一个元素。而本题中询问强制在线，因此考虑使用可持久化线段树维护 $d$ 增加时，选择的方案的变化。这样即可在询问时得到区间内选择的第一个和最后一个元素，同时得到中间部分选择的元素数量。使用这些信息结合之前的讨论即可得到问题的答案。需要注意区间内在方案中只选择了 $0,1$ 个的情况。

复杂度 $O((n+q)\log n)$，可以通过所有子任务。

<div STYLE="page-break-after: always;"> </div>

#### Circuit

##### 算法一

对于一组询问，考虑自下向上确定每个阈值门上的参数，这样可以同时确定每个门的状态。

考虑一个阈值门的情况，对于一个输入门数为 $a$ 的阈值门，如果它的输入门中有 $c$ 个状态为 $1$，则有 $c$ 种方式使它状态为 $1$，有 $a-c$ 种方式状态为 $0$。

可以发现所有门间输入的关系构成一个树结构。那么一种直接的方式是设 $dp_{i,0/1}$ 表示任意选择节点 $i$ 的子树内的参数，有多少种方式使得门 $i$ 的状态为 $0/1$，转移时做类似背包的过程，求出 $f_{i,k}$ 表示有多少种方式决定 $i$ 的每个儿子子树，使得有 $k$ 个儿子的状态为 $1$，然后使用上述方式即可转移。这样的复杂度为 $O(q(n+m)^2)$，可以通过子任务 $1,2,3$。

##### 算法二

考虑上一种算法中一个门状态的转移。可以发现下面这种问题形式得到的转移和上述转移相同：

> 对于每个阈值门，可以选择一个输入它的门，它的状态等于选择的门的状态。

这个问题中，如果输入它的门中有 $c$ 个门状态为 $1$，则有 $c$ 种方式使得它的状态为 $1$，从而两种转移等价。

因此这种形式的问题答案与原问题的答案相同。考虑处理新的问题。如果对于每一个阈值门确定了选择哪个输入，则门 $0$ 的状态只与一个输入门有关，即从门 $0$ 开始在树结构上向下走，每次走到当前门选择的输入，直到到达一个输入门，则门 $0$ 的状态即为这个输入门的状态。

因此考虑对于每个输入门 $u$，记 $f_u$ 表示有多少种对于每个阈值门选择输入的方式，使得从门 $0$ 开始会到达输入门 $u$。记输入门 $u$ 的状态为 $c_u$，由上述分析可以发现问题的答案即为 $\sum_u f_uc_u$。

首先考虑求出所有的 $f_u$，这可以用简单的树型 dp 解决。例如，设 $g_u$ 表示 $u$ 子树内的所有阈值门任意选择的方案数，$h_u$ 表示确定了 $u$ 子树外的所有阈值门的状态，有多少种方式使得从门 $0$ 开始会到达 $u$。则有如下转移：（记 $son_u$ 为 $u$ 的所有输入（即树上儿子节点）构成的集合）
$$
g_u=|son_u|*\prod_{v\in son_u}g_v\\
h_v=h_u*\prod_{i\in son_u,i\neq v}g_i(v\in son_u)
$$
这可以两次 dfs 依次求出。注意在求 $h$ 时，因为模数 $10^9+2022$ 不是质数，因此不能求出 $\prod_{i\in son_u}g_i$ 再乘 $g_v$ 逆元。一种处理方式是将所有儿子排成一列，求出前缀后缀乘积进行转移。

求出 $f$ 后，最后的问题为区间翻转 $c$，求 $\sum_u f_uc_u$，使用线段树即可维护。

复杂度 $O(n+m+q\log m)$，可以通过所有子任务。

<div STYLE="page-break-after: always;"> </div>

#### Insect

##### 算法一

首先考虑如何确定昆虫的种类数。考虑依次尝试将每只昆虫放进设备并进行询问，如果得到的结果大于 $1$ 就将其拿出来。可以发现这样之后每种种类的昆虫一定正好有一只在设备中，这样就得到了种类数。

一种暴力做法是，考虑移除当前在设备中的昆虫，然后对剩余的昆虫重复这一过程，直到某次操作后发现种类数变少，此时之前的操作轮数即为出现次数最少的种类出现的次数。

这样的操作次数为 $n^2$，可以通过子任务 $1$。

##### 算法二

在上述过程中，考虑选择一个值 $d$，依次将每只昆虫放进设备询问，如果得到的结果大于 $d$ 就将其拿出来，否则保留。这样之后如果一种种类的昆虫出现了 $c$ 次，则设备内一定有 $\min(c,d)$ 只这种昆虫。

先使用上述方式求出种类数，设种类数为 $m$，考虑对于一个 $d$进行上述操作，可以通过操作结束后设备中昆虫的数量是否等于 $m*d$ 来判断出现次数最少的种类是否出现了至少 $d$ 次。

因此可以通过这一过程二分答案，这样操作次数为 $n+n\log_2 \frac nm$，特判 $m=1$ 后可以获得约 $50$ 分。

##### 算法三

可以发现上一个算法的一步二分将昆虫分为了设备内和设备外两部分，如果一种种类出现了 $c$ 次，则设备内有 $\min(c,d)$ 只这种昆虫，设备外有 $\max(c-d,0)$ 只。

考虑二分的过程，如果设备内昆虫数量小于 $m*d$，则答案小于 $d$，因此如果一种昆虫出现了大于 $d$ 次，则可以只保留 $d$ 次而不改变答案。这说明这种情况下可以删去当前在设备外的昆虫，只保留当前在设备内的昆虫继续这个过程。

如果设备内昆虫数量等于 $m*d$，则设备内每种种类出现了 $d$ 次，此时可以删去这些昆虫，对剩余部分求出答案，最后将答案加上 $d$ 即可。

因此在一次过程后，可以只保留设备外或设备内的所有昆虫，对这部分求出答案即可得到原问题答案。

设当前昆虫数量为 $n'$，考虑让 $d$ 取接近 $\frac {n'}{2m}$ 的数。可以发现此时无论取到哪种情况，剩余的昆虫数量一定不超过 $m*\lceil\frac{n'}{2m}\rceil$，这与每次减半非常接近，粗略分析可以得到这部分的操作次数不超过 $2(n+m)+m\log_2\frac nm$。如果在求种类数时将得到的 $m$ 只昆虫删去，对剩余部分使用上述方式，可以发现步数不超过 $3n+m\log_2\frac nm$，非常接近 $3n$。这样能得到 $99.89$ 分或者接近的分数。

在此基础上，使用一些乱搞手段（例如在一半附近随机 $d$），或者一些小的常数优化（例如加入前 $d$ 个时不用判断是否需要拿出，或者已经放入 $m*d$ 个时后面可以直接跳过，或者一些基于随机化的方式），有一定概率可以获得 $100$ 分。

<div STYLE="page-break-after: always;"> </div>

#### Island

##### 算法一

记一条在 $(u,v)$ 间往返，且当前停靠在 $u$ 的独木舟为 $(u,v)$，如果它当前停靠在 $v$ 则记为 $(v,u)$。将 $(u,v)$ 看作一条 $u$ 连向 $v$ 的有向边。

首先考虑 $n=2$ 的情况。考虑旅程开始的部分，首先需要使用一条 $(0,1)$ 的独木舟，接下来需要返回 $0$，但不能使用之前的独木舟，因此需要使用一条初始为 $(1,0)$ 的独木舟。接下来所有独木舟的状态与初始状态不同，因此还需要继续进行旅行，可以发现此时必须要另外一条初始状态为 $(0,1)$ 的独木舟。因此必须至少有两条 $(0,1)$ 和一条 $(1,0)$。可以发现有这样的独木舟就能得到合法的旅行：设两条 $(0,1)$ 为 $a,b$，$(1,0)$ 为 $c$，则 $(a,c,b,a,c,b)$ 是一个合理的旅程。

然后考虑子任务 $2$，即所有独木舟构成一个有向完全图。由上一种情况可以发现此时 $n=2$ 无解。而在 $n\geq 3$ 时可以发现一定有解，例如记 $1,2$ 间的边为 $a,b$，$1,3$ 间的边为 $c,d$，则一种解为 $(a,b,c,d,b,a,d,c)$。

这样可以分别通过子任务 $1,2$。

##### 算法二

考虑子任务 $3$，即对于每条边 $(u,v)$，存在它的反向边 $(v,u)$。

此时如果有至少两条从 $0$ 连出的边，则可以使用子任务 $2$ 中的构造得到一个合理的旅程。如果 $0$ 没有出边则显然无解。

考虑 $0$ 只有一条出边的情况，可以发现如下性质：

> 如果 $0$ 只有一条出边 $(0,u)$，则从 $0$ 出发存在合理的旅程当且仅当删去 $0$ 后，从 $u$ 出发存在合理的旅程。从 $0$ 出发的合理旅程为先到达 $u$，然后从 $u$ 出发走一个合理的旅程，最后从 $u$ 使用之前的独木舟返回 $0$。

证明：从 $0$ 出发的旅程必定第一次经过 $(0,u)$，这之后没有独木舟停留在 $0$，因此之后的旅程中，返回 $0$ 后不能离开 $0$，因此只能使用这条独木舟再返回 $0$。因此合理的旅程一定为先经过 $(0,u)$，再使用一些独木舟后回到 $u$，最后使用第一次使用的独木舟回到 $0$。可以发现中间部分为从 $u$ 出发的合理旅程，且这个旅程不经过 $0$。另一方面，如果存在从 $u$ 出发不经过 $0$ 的合理旅程，则可以使用上述方式构造从 $0$ 出发的合理旅程。

因此，如果起点只有一条出边，则可以删去起点，从新的起点继续讨论。如果某一步时起点出边数量大于等于 $2$，则可以得到一种合理的旅程，如果某一步起点没有出边（即图与 $0$ 连通的部分是以 $0$ 为端点的一条链）则可以判断无解。这样可以在 $O(n+m)$ 的复杂度内通过子任务 $3$。

##### 算法三

考虑子任务 $4$，即每条有向边出现了两次。

此时可以发现如果图中存在一个环，则这些重复的边可以组成两个经过的点相同的环。此时可以在这个环上使用类似算法二中的构造：先正向经过第一个环，再正向经过第二个环，再反向经过第一个环，最后反向经过第二个环。这样可以得到一个从环上任意一点出发的合理的旅程。

再使用算法二中的构造方式可以发现，如果从 $0$ 出发沿着有向边走，能走到一个在环上的点，则可以构造如下合理的旅程：先从 $0$ 走到环上点，再在环上进行上述旅程，最后沿着之前使用的边返回。

另一方面，如果从 $0$ 出发不能走到任意一个在环上的点，则从 $0$ 出发能到达的部分形成一个 DAG。可以发现在一个 DAG 上，一个旅程不能沿着之前走过的边折返，因此只能沿着边初始的方向移动，这样不论如何也不能回到 $0$，从而这种情况一定无解。

因此在这个子任务中。可以从 $0$ 出发开始 dfs，判断能否走到一个环上。这样可以在 $O(n+m)$ 的复杂度内通过子任务 $4$。综合上述算法可以得到 $55$ 分。

##### 算法四

上一个算法还有一种描述方式，即如下结论：

> 如果一个点的出度为 $0$，则任何一个合理的旅程不可能经过这个点，可以直接删去这个点。

证明：如果到达了一个初始出度为 $0$ 的点，则可以发现不可能走出这个点。

因此上一个子任务的做法也可以换为，不断删去出度为 $0$ 的点，如果 $0$ 被删去则无解，否则一定有解，构造方案可以按照上面的方式。



考虑一般情况的问题。由上两个算法，可以得到如下结论：

1. 如果一个点出度为 $0$，则可以直接删去。删去起点则说明无解。
2. 如果起点出度为 $1$，则可以删去起点，将新的起点变为原先起点连向的点。

考虑在图上重复使用这两个结论，直到发现无解或者没有一个点满足任意一个条件。对于后一种情况，此时起点出发有至少两条出边，其余每个点至少有一条出边。

可以发现此时一定存在合理的旅程，下面给出一种构造方式：

考虑对于除去起点外的每个点钦定一条出边，使得走到这个点后下一步走这条出边。则从起点的任意一条出边开始走，使用这种方式，一定可以走到一个钦定的出边组成的环或者走回起点（此时也相当于走出了一个环）。

此时考虑起点的两条出边走出的路径，有两种情况：

1. 两条路径不经过重复边。此时可以结合上两种算法的构造，即先走第一条路径，经过环后沿着路径返回起点，然后走第二条路径和环，接下来重复这个过程，但反向经过两个环。
2. 两条路径经过了重复边，此时因为每个点钦定了一条出边，因此两条路径一定会走到同一个环上，即存在一个环，起点有两条出边都可以通过某条路径到达环上。此时可以使用类似的构造：先走第一条路径，经过环后返回，然后走第二条路径，反向经过环后返回。

这样完成了所有情况的构造，且每种情况中总边数都不超过 $4m$，符合要求。

复杂度 $O(n+m)$，可以通过所有子任务。