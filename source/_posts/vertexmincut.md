---
title: '[paper] Vertex Cuts'
date: '2025-05-22 06:46:50'
updated: '2025-05-22 06:46:50'
tags: Fancia
permalink: Photopsia/
description: Vertex Cuts
mathjax: true
---

### Vertex Minimum Cut

一个 Vertex Cut 表示删掉一些点，使得剩下部分包含至少有两个连通块。当然有特殊情况（完全图），这里为了简便略过。

我们可以用一组点的（非空）划分 $L,S,R$ 表示这个割，它的含义是，删掉 $S$ 后，两部分 $L,R$ 间不连通。然后最小割就是找到一个最小的 $|S|$。

可以类似的定义 $s-t$ Vertex Cut，那做这个只需要拆点网络流。

#### Vertex Isolating Cut

回顾一般(Edge)的 Isolating Cut：给一组点 $T$，对于每个 $t_i$，找到最小的把它和别的 $t_j$ 分开的割。

自然(?)的想法是按照二进制表示分组，然后 $O(\log n)$ 次最小割（第 $i$ 次按照第 $i$ 位分两侧）。现在把所有割叠起来，我们就能得到一组 Isolating Cut。但这东西不一定是最优的——考虑一个菊花，外面都是端点，那最优解不应该占中间的位置。

所以实际上是什么情况呢？考虑 $t_i$ 真正的 Isolating Cut，我们有如下结论：

> 割的权值是 Submodular Function。即 $f(S_1)+f(S_2)\geq f(S_1\cap S_2)+f(S_1\cup S_2)$。

证明：考虑每条边的贡献。分类讨论一下。

> 如果 $S_1$ 是最小割，$S_2$ 是某一个割，则 $S_1\cap S_2$ 不比 $S_2$ 差。更一般的，如果 $S_2$ 是最小割，那它们的交也是最小割。

证明：如果不对，那么 Submodular 说明 $S_1\cup S_2$ 是一个比 $S_1$ 更好的割，矛盾。

后面一步说明，存在一个“最小”的最小割，使得所有最小割都包含它。同时，考虑上面的每一步割，其必定完全包含这个最小割，否则交一下我们会得到更小的最小割。

因此这个割一定在上一步求出来的不一定最优的 Isolating Cut 里面，因此对每一块分开跑一次 Isolating Cut 就行了。

在 Vertex 的情况里面，考虑让割的权值是和 $S$ 相邻的外部点数量，枚举情况（现在情况会变多，需要考虑连到了哪几块）可知上述性质仍然成立，因此还是可以 Isolating Cut。

#### Easy Cases with Isolating Cut

我们再来回顾一下 Isolating Cut 的作用。在 Edge Case 里面，一个经典的例子是用 Sampling 做全局最小割：考虑随机 $1/2,1/4,1/8,\ldots$ 概率采样。那么总有一组有很大概率满足：最小割一侧采样了一个，另外一侧采样了至少一个。此时就是一个 Isolating Cut。 

对于 Vertex Cut，我们可以类似考虑 Sampling。那么不妨假设 $|L|\leq |R|$，然后我们按照差不多 $1/|L|$ 的概率采样……和之前不一样的是，现在还有中间删的点 $S$。如果我们也选了 $S$ 里面的点，那 Isolating Cut 就不能找到这个割。

因此 $|L|\geq |S|$ 的情况是简单的。也可以说，$|L|\geq |S|/polylog$ 都是简单的，毕竟只需要多来 polylog 次。

当然可能会有神奇情况，比如有两个 Terminal 相邻，但我们可以说明，这种情况的割不会导致神奇情况，因此遇到神奇情况直接两个 Terminal 都扔了就行了。

#### Remaining Cases

现在的情况是，$L$ 比 $S$ 小很多。看看最小割 $L,S,R$ 里面发生了啥。这样的话，$L$ 里面的点必须连出 $k$ 条边，而那些又不能连到 $R$。而 $L$ 又远比 $S$ 小，所以它实际上连接了 $S$ 中绝大多数的点：任取一个 $L$ 中的点，在 $L,S$ 中，至多只有 $k/polylog$ 个点没有和它相邻。

这个数量实际上和 $L$ 一样，也就是说，任意固定一个 $x\in L$，采样选到 $S$ 里面不和 $x$ 相邻这件事是很可能发生的。如果我们能把和 $L$ 相邻的点从 Terminal 里面删了，就能考虑到这个最小割。换言之，我们希望：

> 对于每一个点 $x\in T$，求出 $x$ 到 $T$ 中不考虑和 $x$ 相邻点部分的最小割。

这也可以看成有相邻情况的另一种 Isolating Cut 的解释。坏消息是之前那个做法就用不了了。

不过这个时候，Isolating Cut 非常神奇。我们先考虑之前的版本，忽略 Terminal 不能相交的问题，看成每个 $t_i$ 找一个不包含其它 $t_j$ 的点集，然后最小化 $\partial S$ 的点数。此时度数为 $k$，而 Terminal 总共有 $npoly\log/k$ 个。那么可以发现，每个点都连接了一万个 Terminal。因此可以发现最小割就是单点 $x$：我们考虑最大流最小割来证明，那从 $x$ 出发，每流到一个别的点都可以直接进 Terminal。由此可以发现最小割就是取单点。

回到上面的情况，我们刚才实际上说了，如果一个点连到了另外一个 Terminal，那我们就不会把它放在割的这一侧。刚才我们发现，按照 $1/|L|$ 的概率选，那每个点都连到了一个 Terminal。现在我们选了一个 $x$，然后不考虑和 $x$ 相连的那些。考虑此时有多少个点没有连到右边的 Terminal。如果这个数非常小，那我们不如忽略 Isolating Cut 那堆做法，直接对每个问题暴力做。

随机可知，记 $N[x]$ 表示 $x$ 以及和 $x$ 相邻的点构成的集合，则如果一个点向 $N[x]$ 外连了 $l*polylog=|L|$ 条边，那它就很大概率会选到某个 Terminal。**这只有n^2个事件，所以我们可以确保这一定发生。** 但一个点应该有 $k$ 的度数，所以它有 $k-l*polylog$ 的度数都连到了只有 $k$ 个点的 $S$……这可能没有问题，因为可能 $S$ 里面每个点度数都是 $n$。可以发现这样一个二分图的 Case：左边 $k$ 个点，右边 $n$ 个点，然后右边没被选的点都不和 Terminal 相连。（为了后面的分析，你也可以考虑右边有两层，然后我们选了第二层的点）

##### Degree Separation and Sparsifiers

刚才坏的情况是 $S$ 里面每个点度数都非常大。与此同时，我们知道 $L$ 里面每个点度数都比较小。回想一下，我们之前 Sampling 的问题是，Sample 到 $L$ 的时候必定选了一大堆 $S$ 里面的东西。那现在，我们有了一个避免这种情况的方法：考虑只选择度数 $\leq 2k$ 的。但还有个问题，可能 $R$ 里面也没有度数很小的点，这怎么办？

因此就需要拿出上次说的 Vertex Mincut Sparsifier，让边数变成 $nk$，然后度数和就是 $2nk$ 了。

这样我们可以看出，如果 $S$ 里面有 $l*polylog$ 个点度数很小，那这样 Sample 都可以把这组割找到。否则呢？之前我们说，每个剩下的点连到了 $k-l*polylog$ 个点上，那这就连到了至少一半度数很小的点上，从而剩下的只有 $O(k)$ 个点。

##### Size Analysis, Pruning Rules

现在我们来分析它的复杂度。每一轮里面，我们枚举 $L$，然后跑 $n/l$ 个上述问题。现在需要考虑每个图的大小是多少。

根据刚才的分析，有 $k$ 个和 $x$ 相邻的点，$k$ 个其它点，剩下的都和右边的 Terminal 相邻。首先我们把 Terminal 缩起来。对于右边和 Terminal 相邻的点，类似之前流的想法，我们到了这里就一定会直接走到 Terminal，所以：

1. 我们可以删掉这些点之间的边，只用保留一条到 Terminal 的边和那些外面连过来的边。
2. 这样搞完之后，如果一个点只连向 Terminal，那不如把它删了。或者说，我们只考虑左边那 $O(k)$ 个点能直接到的点。

从而右边的大小不超过左边 $O(k)$ 个点的度数和。但左边甚至可能有度数为 $n$ 的点…………

但只要有这样的点，它一定直连了 Terminal。那这时，

3. 一个点同时连了两侧，那它一定在 Vertex Mincut 里面，所以直接删了得了。

这样的话，和之前类似，每个点连到 $N[x]$ 外面的度数不超过 $l*polylog$。因此每个点度数就是 $O(k+l*poly\log)$。

那大小显然不超过 $\tilde O(k^2)$。这够了吗？如果 $l\approx k/poly\log$，那很好。但我们并不知道 $l,k$ 是多少。常规手段是，先搞一个 $k$ 的近似，然后枚举 $l$ 做上述过程。这样的话，对于小的 $l$，这个复杂度就太大了。

再注意到根据对称性，我们也可以把 $N(x)$ 之间的边删掉，此时每个点往其它点的边数和是 $l*poly\log n$，并且 $N(x)$ 内部没有变了，那么总大小就是 $\tilde O(kl)$ 了。

此时跑 $n/l$ 轮，总大小是 $\tilde O(nk)=\tilde O(m)$。最后，因为搞完还是需要求最小割，我们的复杂度完全取决于网络流的复杂度。

##### Implementation Analysis, Linear Sketching

还有个问题：怎么构造这个图？这里把图扫一遍都是不能接受的。同时也不能跑出来一个 $O(k^2)$ 的复杂度。

但仔细想想，我们只需要干这件事：

1. 从 $x$ 相邻的点开始 bfs。
2. 到某个点时，我们只需要枚举它向 $N[x]$ 以外的边然后继续 bfs。
3. 如果搜一个点和 Terminal 相邻，那可以直接停了。

那只需要如下步骤：对于每个点，判定它是否和 $N[x]$ 外的 Terminal 相邻，然后输出它和 $N[x]$ 之外的边。

这非常恶心，但注意到有很高概率，第一个条件仅当和 $N[x]$ 之外的边数只有 $l*poly\log$，而枚举这么多实际上不影响复杂度。那么问题变为，快速计算这个值，在合理情况下输出所有相邻的边。

于是有个东西叫做 Sketching，某篇 paper 支持把 $[-v,v]^n$ 映射到 $Z^k$，满足如果只有 $k$ 个非零那我们就能还原。另一篇 paper 支持估计非零的数量。

同时，这两个构造都是线性的，所以 $f(u-v)=f(u)-f(v)$。

注意到每个点实际上大部分度数都在 $N[x]$ 里面，考虑计算 $N[u]-N[x]$，那么这里有 $u$ 连向的不在 $N[x]$ 里面的，还有 $N[x]$ 里面没被连到的，但后者也是 $\leq l*poly\log$，所以这样搞就可以 Sketch 出来。

#### Directed Cases

实际上和之前差不多。坏消息是，直接搞会有如下问题：

1. 并没有什么 Directed Isolating Cut。问题是两个方向最小割可能不同，从而复杂度不对。
2. 中间某一步我们考虑说额外的点都连向了 $N[x]$，所以如果这些点数很多，那 $N[x]$ 里面不可能每个点度数都很少。但现在要分入度出度。我们知道 $L$ 里面的点出度都很少，但这里向 $N[x]$ 连的是入度，所以这不靠谱。

好消息是，剩下的部分都是对的。这包括暴力做每个 Cut，数出度看是否和 Terminal 相邻，Pruning 删点，以及对出边做 Sketching。这样的话每次跑的网络流是 $nl$ 大小而不是 $kl$ 大小。同时 Isolating Cut 那边做不了，所以可以改成暴力做 $n/l$ 次。